<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能英语单词默写 Pro</title>
    <style>
        /* General Body Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Main Container */
        .container {
            width: 100%;
            max-width: 800px; /* Increased max-width for typing practice */
            background-color: #ffffff;
            padding: 25px 30px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden; /* Prevents box shadow from being cut off */
        }

        /* Loading Overlay */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.85);
            z-index: 10;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border-radius: 12px;
        }
        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #007bff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        #loader p {
            margin-top: 15px;
            font-weight: bold;
            color: #007bff;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Headings */
        h1, h2, h3, h4 {
            text-align: center;
            color: #0056b3;
            margin-bottom: 20px;
        }

        p {
            line-height: 1.6;
            text-align: center;
            color: #555;
            margin-bottom: 20px;
        }

        /* Text Area for Word Input */
        textarea {
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
            box-sizing: border-box;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.15);
        }
        
        /* File Upload Styles */
        .upload-section {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        }
        #upload-status {
            color: #666;
            margin-top: 10px;
            min-height: 20px;
            font-style: italic;
        }
        .upload-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        #image-upload {
            display: none;
        }

        /* Buttons */
        button {
            display: block;
            width: 100%;
            padding: 12px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, box-shadow 0.3s ease, opacity 0.3s;
        }
        button.secondary {
            background-color: #6c757d;
        }
        button.tertiary {
            background-color: #28a745;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
        button.tertiary:hover {
            background-color: #218838;
        }
        button:disabled {
            background-color: #a0a0a0;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.7;
        }
        button:hover:not(:disabled) {
            background-color: #0056b3;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.2);
        }

        /* Quiz Section Styles */
        .quiz-section, #mc-quiz-section { display: none; }
        .quiz-header { display: flex; justify-content: space-between; align-items: center; }
        .progress { color: #666; font-size: 16px; }
        .chinese-prompt { font-size: 2.2rem; font-weight: bold; text-align: center; margin: 20px 0; padding: 25px; background-color: #e9f5ff; border-radius: 8px; color: #0056b3; word-wrap: break-word; }
        #english-input { width: 100%; padding: 15px; font-size: 22px; text-align: center; border: 2px solid #ccc; border-radius: 8px; box-sizing: border-box; margin-bottom: 15px; letter-spacing: 2px; }
        #english-input:focus { outline: none; border-color: #007bff; }
        #feedback, #mc-feedback { text-align: center; font-size: 18px; font-weight: bold; min-height: 25px; margin-bottom: 15px; transition: color 0.3s; }
        .correct { color: #28a745; }
        .incorrect { color: #dc3545; }
        .button-group { display: flex; flex-direction: column; gap: 10px; }
        .quiz-actions { display: flex; gap: 10px; }

        /* Completion Section Styles */
        .completion-section { display: none; text-align: center; }
        .completion-section h2 { color: #28a745; }
        #score-display { font-size: 22px; margin: 20px 0; }
        #wrong-words-list { text-align: left; margin-top: 20px; }
        #wrong-words-list h3 { text-align: center; color: #dc3545; }
        #wrong-words-list ul { list-style-type: none; padding: 0; }
        #wrong-words-list li { background-color: #fff8f8; border: 1px solid #f5c6cb; border-radius: 4px; padding: 10px; margin-bottom: 8px; }

        /* Checkbox style */
        .checkbox-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px; /* Adjusted margin */
            gap: 10px;
            font-size: 16px;
            color: #555;
        }

        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #007bff; /* Colors the checkbox itself */
            cursor: pointer;
        }

        /* Radio button container */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 16px;
            color: #333;
        }

        .radio-group input[type="radio"] {
            accent-color: #007bff;
            width: 18px;
            height: 18px;
        }
        
        /* Section for specific mode settings */
        .mode-setup-section {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
        }
        .mode-setup-section h3 {
            text-align: center;
            color: #0056b3;
            margin-top: 0;
            margin-bottom: 10px;
        }

        /* Inline Wrong Words Selection Styles */
        #inline-wrong-words-sessions-list {
            max-height: 300px; /* Scrollable area for sessions */
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
            flex-grow: 1; /* Allow it to grow */
        }

        .session-item {
            display: flex;
            flex-direction: column;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .session-item:last-child {
            border-bottom: none;
        }

        .session-item:hover {
            background-color: #f5f5f5;
        }

        .session-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .session-header input[type="checkbox"] {
            margin-right: 10px;
            accent-color: #007bff;
        }

        .session-header .session-info {
            flex-grow: 1;
            font-size: 14px; /* Slightly smaller font for more info */
        }
        .session-info .session-mode {
             display: block;
             font-size: 0.9em;
             color: #666;
        }

        .session-header .toggle-icon {
            font-size: 1.2em;
            margin-left: 10px;
            transition: transform 0.2s ease;
        }

        .session-header .toggle-icon.expanded {
            transform: rotate(90deg);
        }

        .session-words-list {
            list-style-type: none;
            padding-left: 30px; /* Indent the list */
            margin-top: 10px;
            margin-bottom: 0;
            font-size: 0.9em;
            color: #666;
            display: none; /* Hidden by default */
        }

        .session-words-list.show {
            display: block;
        }

        .session-words-list li {
            margin-bottom: 5px;
        }
        .session-words-list .correct { color: #28a745; }
        .session-words-list .incorrect { color: #dc3545; }

        .inline-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end; /* Align buttons to the right */
            margin-top: 15px;
        }

        .inline-buttons button {
            width: auto; /* Allow buttons to size based on content */
            padding: 10px 20px;
            font-size: 16px;
        }

        /* General Message Dialog */
        #message-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            padding: 25px;
            z-index: 1001; /* Higher than example sentence display */
            max-width: 400px;
            text-align: center;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 20px;
        }
        #message-dialog-text {
            font-size: 1.1em;
            color: #333;
            line-height: 1.6;
        }
        #message-dialog-close-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            align-self: center;
        }
        #message-dialog-close-button:hover {
            background-color: #0056b3;
        }

        /* Example Sentence Container */
        #example-sentence-container {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 8px;
            text-align: center;
        }
        #example-sentence-container p {
            margin: 0;
            line-height: 1.5;
        }
        #english-example-sentence {
            font-weight: bold;
            color: #0056b3;
            margin-bottom: 5px;
        }
        #chinese-example-sentence {
            color: #666;
        }

        /* Word Library Specific Styles */
        .word-library-selection-display {
            text-align: center;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            min-height: 20px; /* Ensure space even if nothing selected */
        }
        .word-library-selection-display span {
            color: #007bff;
        }

        /* Modal for Word Library Management */
        #word-library-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        .modal-header h2 {
            margin: 0;
            color: #0056b3;
        }
        .modal-close-button {
            background: none;
            border: none;
            font-size: 24px;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: auto; /* Override general button width */
            transition: color 0.2s;
        }
        .modal-close-button:hover {
            color: #333;
        }

        .modal-section {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .modal-section h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #0056b3;
        }
        .modal-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 5px;
            background-color: #fff;
        }
        .modal-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .modal-list-item:last-child {
            border-bottom: none;
        }
        .modal-list-item:hover {
            background-color: #f5f5f5;
        }
        .modal-list-item.selected {
            background-color: #e6f2ff;
            border-color: #007bff;
            font-weight: bold;
        }
        .modal-list-item.disabled {
            background-color: #f8f8f8;
            color: #aaa;
            cursor: not-allowed;
        }
        .modal-list-item button {
            width: auto;
            padding: 5px 10px;
            font-size: 14px;
            margin-left: 10px;
        }
        .modal-input-group {
            display: flex;
            gap: 10px;
        }
        .modal-input-group input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
        }
        .modal-input-group button {
            width: auto;
            padding: 8px 15px;
            font-size: 16px;
        }

        /* Modal specific mode styles */
        #word-library-modal[data-mode="select"] .manage-only { display: none; }
        #word-library-modal[data-mode="manage"] .select-only { display: none; }

        /* Styles for Practice Selection Tree */
        #library-selection-tree { max-height: 40vh; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; padding: 10px; background-color: #fff; }
        .library-node > .library-header { font-size: 1.1em; font-weight: bold; padding: 10px; background-color: #f0f2f5; border-radius: 4px; margin-bottom: 5px; }
        .subset-node { margin-left: 20px; }
        .subset-header { display: flex; align-items: center; padding: 8px; cursor: pointer; border-radius: 4px; transition: background-color 0.2s; }
        .subset-header:hover { background-color: #f5f5f5; }
        .subset-header input[type="checkbox"] { margin-right: 10px; }
        .subset-toggle { margin-right: 8px; transition: transform 0.2s; display: inline-block; }
        .subset-toggle.expanded { transform: rotate(90deg); }
        .words-list-container { list-style-type: none; padding-left: 40px; display: none; }
        .words-list-container.show { display: block; }
        .word-item { display: flex; align-items: center; padding: 5px 0; }
        .word-item input[type="checkbox"] { margin-right: 10px; }
        .word-item label { color: #555; }

        /* Flashcard Styles */
        #flashcard-section {
            display: none;
            flex-direction: column;
            gap: 15px;
        }
        .flashcard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .flashcard-progress {
            font-size: 16px;
            color: #666;
        }
        .flashcard {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            text-align: center;
            position: relative;
            min-height: 350px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .flashcard-word {
            font-size: 3rem;
            font-weight: bold;
            color: #0056b3;
            margin-bottom: 10px;
        }
        .flashcard-pos {
            font-style: italic;
            color: #666;
            margin-bottom: 20px;
        }
        .flashcard-chinese {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 25px;
        }
        .flashcard-example {
            font-size: 1rem;
            line-height: 1.5;
            color: #555;
            width: 100%;
        }
        .flashcard-example .eng {
            font-weight: bold;
        }
        .flashcard-nav {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-top: 20px;
        }
        .flashcard-nav button, #flashcard-speak-button {
            width: 100%;
        }
        #flashcard-speak-button {
            margin-top: 15px;
        }
        #flashcard-completion-options {
            display: none;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        .flashcard .spinner-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
        }

        /* Mode Selection Styles */
        #mode-selection-section {
            display: none;
            text-align: center;
        }
        #mode-selection-section h2 {
            margin-bottom: 25px;
        }
        #mode-selection-section .button-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* --- Multiple Choice Styles --- */
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .input-group label {
            white-space: nowrap;
        }
        .input-group input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }
        #mc-quiz-prompt {
            text-align: center;
            margin: 20px 0;
        }
        #mc-quiz-prompt button {
            width: auto;
            padding: 20px 30px;
            font-size: 24px;
            background-color: #e9f5ff;
            color: #0056b3;
            border: 2px solid #007bff;
        }
        #mc-quiz-prompt button:hover {
            background-color: #d1e7ff;
        }
        #mc-options-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        .mc-option-button {
            padding: 18px;
            font-size: 18px;
            font-weight: bold; /* Make English bold */
            background-color: #fff;
            color: #333;
            border: 1px solid #ccc;
            text-align: center;
            line-height: 1.4; /* Adjust line height for two lines */
        }
        .mc-option-button:hover:not(:disabled) {
            background-color: #f8f9fa;
            border-color: #007bff;
        }
        .mc-option-button.correct-answer {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        .mc-option-button.wrong-answer {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            opacity: 0.7;
        }
        
        /* --- Typing Practice Styles --- */
        #typing-practice-section {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
        }
        /* ADDED: Rule to push title down */
        #typing-practice-section h2 {
            margin-top: 140px; 
        }
        #keyboard-container {
            position: relative;
            width: 100%;
            max-width: 750px;
            margin-top: 0; /* REMOVED margin */
        }
        #keyboard-img {
            width: 100%;
            height: auto;
            border-radius: 8px;
        }
        #next-char-indicator {
            position: absolute;
            font-size: 48px;
            font-weight: bold;
            color: #dc3545;
            background-color: rgba(255, 255, 0, 0.7);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-transform: uppercase;
            pointer-events: none;
            transition: top 0.1s, left 0.1s;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);
            display: none; /* Hidden initially */
        }
        #typing-info {
            text-align: center;
            font-size: 22px;
            font-weight: bold;
            color: #0056b3;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        #typing-info .new-record {
            color: #e67e22;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        #leaderboard {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 200px;
        }
        #leaderboard h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #0056b3;
            text-align: center;
        }
        #leaderboard ol {
            margin: 0;
            padding-left: 20px;
            font-size: 14px;
        }
        #leaderboard li {
            margin-bottom: 5px;
            color: #333;
        }
        #typing-back-button {
            width: auto;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
        }

    </style>
</head>
<body>

    <div class="container">
        <div id="loader">
            <div class="spinner"></div>
            <p id="loader-text">正在处理...</p>
        </div>

        <div id="setup-section">
            <h1>智能英语单词默写</h1>
            <p>选择一种练习模式开始。</p>
            
            <div class="radio-group">
                <label>
                    <input type="radio" name="practice-mode" value="new-words" id="new-words-radio" checked>
                    单词拼写练习
                </label>
                <label>
                    <input type="radio" name="practice-mode" value="mc-quiz" id="mc-quiz-radio">
                    单词选择题
                </label>
                <!-- NEW: Typing Practice Radio Button -->
                <label>
                    <input type="radio" name="practice-mode" value="typing-practice" id="typing-practice-radio">
                    打字练习 (a-z)
                </label>
                <label>
                    <input type="radio" name="practice-mode" value="wrong-words" id="wrong-words-radio" disabled>
                    错题练习 (<span id="wrong-words-count">0</span> 个单词)
                </label>
                <label>
                    <input type="radio" name="practice-mode" value="word-library" id="word-library-radio">
                    单词库拼写
                </label>
            </div>

            <div id="new-words-input-area" class="mode-setup-section" style="display: flex;">
                <h3>新单词拼写</h3>
                <textarea id="word-input" placeholder="方法一：在此处输入单词..."></textarea>
                <div class="upload-section">
                    <p style="margin-bottom: 10px;">方法二：上传单词文件 (图片, TXT, PDF, Word, HEIC等)</p>
                    <div class="upload-buttons">
                        <button id="select-file-button" class="secondary">选择文件</button>
                        <button id="upload-confirm-button" disabled>上传并识别</button>
                    </div>
                    <div id="upload-status">未选择任何文件</div>
                </div>
                <input type="file" id="file-upload" accept="image/*,.txt,.csv,.doc,.docx,.xls,.xlsx,.pdf,.heic" style="display: none;">
            </div>
            
            <div id="multiple-choice-setup-area" class="mode-setup-section">
                <h3>单词选择题设置</h3>
                <div class="radio-group" style="background-color: transparent; border: none; padding: 0;">
                    <label><input type="radio" name="mc-source" value="random" checked> 从单词库随机抽取</label>
                    <div id="mc-random-options" class="input-group" style="padding-left: 25px;">
                        <label for="random-word-count-input">数量:</label>
                        <input type="number" id="random-word-count-input" value="10" step="5" min="5">
                        <span>(从总库 <span id="total-word-count">0</span> 个词中)</span>
                    </div>
                    <label><input type="radio" name="mc-source" value="manual"> 从单词库手动选择</label>
                    <div id="mc-manual-options" style="display: none; padding-left: 25px;">
                        <div id="mc-selected-display" class="word-library-selection-display">未选择单词</div>
                        <button id="select-mc-words-button" class="secondary" style="font-size: 16px; padding: 10px;">打开单词库选择</button>
                    </div>
                </div>
            </div>

            <div id="inline-wrong-words-selection" class="mode-setup-section">
                <h3>选择错题练习会话</h3>
                <div id="inline-wrong-words-sessions-list" class="modal-sessions-list"></div>
                <div class="inline-buttons">
                    <button id="clear-wrong-words-button" class="secondary">清除所有错题记录</button>
                </div>
            </div>

            <div id="word-library-selection-area" class="mode-setup-section">
                <h3>单词库拼写</h3> 
                <div id="selected-library-display" class="word-library-selection-display">未选择单词</div>
                <div style="display: flex; gap: 10px; flex-direction: column;">
                    <button id="select-library-for-practice-button">选择单词进行练习</button>
                    <button id="open-manage-modal-button" class="secondary">管理单词库 (创建/删除/编辑)</button>
                </div>
            </div>
            
            <!-- This section is for modes that don't need specific setup, like typing -->
            <div id="simple-mode-area" class="mode-setup-section">
                 <h3>打字练习</h3>
                 <p>准备好后，点击“准备开始”即可进入打字练习界面。</p>
            </div>


            <div id="common-settings" style="margin-top:20px;">
                <div class="checkbox-container">
                    <input type="checkbox" id="auto-speak-checkbox" checked>
                    <label for="auto-speak-checkbox">自动读出单词</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="google-tts-checkbox">
                    <label for="google-tts-checkbox">使用更自然的 Google 翻译语音 (实验性)</label>
                </div>
            </div>

            <button id="start-button" disabled>准备开始</button>
        </div>

        <div id="mode-selection-section">
            <h2>准备就绪！</h2>
            <p>已成功加载 <strong id="mode-selection-word-count">0</strong> 个单词。</p>
            <div class="button-group">
                <button id="mode-select-flashcard" class="tertiary">单词卡复习</button>
                <button id="mode-select-practice">直接开始练习</button>
                <button id="mode-select-back" class="secondary">返回</button>
            </div>
        </div>

        <div id="flashcard-section">
            <div class="flashcard-header">
                <div id="flashcard-progress" class="flashcard-progress"></div>
                <button id="flashcard-back-to-menu-button" class="secondary" style="width: auto; padding: 8px 12px; font-size: 14px;">返回主页</button>
            </div>
            <div class="flashcard">
                <div class="spinner-container" style="display: none;"><div class="spinner"></div></div>
                <div id="flashcard-content">
                    <div id="flashcard-word" class="flashcard-word"></div>
                    <div id="flashcard-pos" class="flashcard-pos"></div>
                    <div id="flashcard-chinese" class="flashcard-chinese"></div>
                    <div id="flashcard-example" class="flashcard-example">
                        <p class="eng"></p>
                        <p class="chn"></p>
                    </div>
                </div>
            </div>
            <button id="flashcard-speak-button" class="secondary">读出单词</button>
            <div id="flashcard-nav" class="flashcard-nav">
                <button id="flashcard-prev-button">上一个</button>
                <button id="flashcard-next-button">下一个</button>
            </div>
            <div id="flashcard-completion-options">
                <h3>复习完毕！</h3>
                <button id="flashcard-finish-practice-button">开始练习</button>
                <button id="flashcard-finish-menu-button" class="secondary">返回主菜单</button>
            </div>
        </div>
        
        <div id="mc-quiz-section">
            <div class="quiz-header">
                <div id="mc-progress" class="progress"></div>
                <button id="mc-back-to-menu-button" class="secondary" style="width: auto; padding: 8px 12px; font-size: 14px;">返回主页</button>
            </div>
            <div id="mc-quiz-prompt">
                <button id="mc-speak-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-volume-up-fill" viewBox="0 0 16 16">
                      <path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/>
                      <path d="M10.121 12.596A6.48 6.48 0 0 0 12.025 8a6.48 6.48 0 0 0-1.904-4.596l-.707.707A5.482 5.482 0 0 1 11.025 8a5.482 5.482 0 0 1-1.61 3.89l.706.706z"/>
                      <path d="M8.707 11.182A4.486 4.486 0 0 0 10.025 8a4.486 4.486 0 0 0-1.318-3.182L8 5.525A3.489 3.489 0 0 1 9.025 8 3.49 3.49 0 0 1 8 10.475l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06z"/>
                    </svg>
                </button>
            </div>
            <div id="mc-options-container"></div>
            <div id="mc-feedback"></div>
            <div class="button-group" style="margin-top: 20px;">
                <button id="mc-next-button" style="display: none;">下一题</button>
            </div>
        </div>

        <div id="quiz-section" class="quiz-section">
            <div class="quiz-header">
                <div id="progress" class="progress"></div>
                <button id="back-to-menu-button" class="secondary" style="width: auto; padding: 8px 12px; font-size: 14px;">返回主页</button>
            </div>
            <div id="chinese-prompt" class="chinese-prompt"></div>
            <input type="text" id="english-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
            <div id="feedback"></div>

            <div id="example-sentence-container" style="display: none;">
                <p style="font-style: italic; color: #555;">例句:</p>
                <p id="english-example-sentence"></p>
                <p id="chinese-example-sentence"></p>
            </div>

            <div class="button-group">
                 <div class="quiz-actions">
                    <button id="check-button">检查答案</button>
                    <button id="next-button" style="display: none;">下一题</button>
                </div>
                <button id="speak-again-button" class="secondary">再读一次</button> 
            </div>
        </div>

        <div id="completion-section" class="completion-section">
            <h2>练习结束！</h2>
            <div id="score-display"></div>
            <div id="wrong-words-list"></div>
            <button id="restart-button">返回主页</button>
        </div>
        
        <!-- NEW: Typing Practice Section -->
        <div id="typing-practice-section">
            <div id="leaderboard">
                <h4>🏆 英雄榜 🏆</h4>
                <ol id="leaderboard-list"></ol>
            </div>
            <h2>A-Z 打字练习</h2>
            <div id="keyboard-container">
                <img id="keyboard-img" src="https://github.com/ashinxtc/vocabulary-tool/blob/main/KB_United_States.svg.png?raw=true" alt="US Keyboard Layout">
                <div id="next-char-indicator">A</div>
            </div>
            <div id="typing-info">
                <p>请按 'a' 键开始新一轮练习</p>
            </div>
            <button id="typing-back-button" class="secondary">返回主菜单</button>
        </div>
    </div>

    <div id="message-dialog">
        <p id="message-dialog-text"></p>
        <button id="message-dialog-close-button">确定</button>
    </div>

    <div id="word-library-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">管理单词库</h2>
                <button class="modal-close-button" id="modal-close-button">&times;</button>
            </div>

            <!-- This container will be used for both 'manage' and 'select' modes, with visibility controlled by JS -->
            <div id="manage-view">
                <div class="modal-section">
                    <h4>我的单词库</h4>
                    <div class="modal-input-group">
                        <input type="text" id="new-library-name-input" placeholder="新单词库名称">
                        <button id="create-library-button">创建</button>
                    </div>
                    <div id="libraries-list" class="modal-list"></div>
                </div>

                <div class="modal-section" id="subset-management-section" style="display: none;">
                    <h4><span id="current-library-name"></span> 的子集</h4>
                    <div class="modal-input-group">
                        <input type="text" id="new-subset-name-input" placeholder="新子集名称">
                        <button id="create-subset-button">创建</button>
                    </div>
                    <div id="subsets-list" class="modal-list"></div>
                </div>

                <div class="modal-section" id="words-management-section" style="display: none;">
                    <h4>向 <span id="current-subset-name"></span> 添加单词</h4>
                    <textarea id="subset-words-input" placeholder="每行一个单词，格式：英文 - 中文"></textarea>
                    
                    <div class="upload-section" style="border: 1px dashed #ccc; padding: 10px; margin-top: 10px;">
                        <p style="margin-bottom: 10px; font-size: 14px;">或从文件导入单词</p>
                        <div class="upload-buttons" style="flex-direction: column;">
                            <button id="select-subset-file-button" class="secondary" style="width: 100%; margin-bottom: 5px;">选择文件</button>
                            <button id="upload-subset-confirm-button" disabled style="width: 100%;">上传并识别/导入</button>
                        </div>
                        <div id="subset-upload-status" style="color: #666; margin-top: 5px; min-height: 20px; font-style: italic; font-size: 14px;">未选择任何文件</div>
                    </div>
                    <input type="file" id="subset-file-upload" accept="image/*,.txt,.csv,.doc,.docx,.xls,.xlsx,.pdf,.heic" style="display: none;">
                    
                    <button id="save-subset-words-button">保存单词到子集</button>
                </div>
            </div>

            <!-- NEW: View for selecting words for practice -->
            <div id="select-view" style="display: none;">
                 <div class="modal-section">
                    <h4>选择要练习的单词 (<span id="selected-word-count">0</span>)</h4>
                    <div id="library-selection-tree">
                        <p style="text-align: center; color: #777;">正在加载单词库...</p>
                    </div>
                </div>
                <button id="confirm-library-selection-button" disabled>确认选择并返回</button>
            </div>

        </div>
    </div>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, where, getDocs, addDoc, setDoc, doc, onSnapshot, deleteDoc, writeBatch, serverTimestamp, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables
        let app;
        let db;
        let auth;
        let userId = 'anonymous'; // Default to anonymous
        let isAuthReady = false;

        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyAOPiAwJCh61dH-rMBWfOM1nKZjiID6G-s",
            authDomain: "vocabulary-29bb0.firebaseapp.com",
            projectId: "vocabulary-29bb0",
            storageBucket: "vocabulary-29bb0.firebasestorage.app",
            messagingSenderId: "480495077641",
            appId: "1:480495077641:web:6cd7b1bea6a2a70f342bd8",
            measurementId: "G-VJ6E7C5S6V"
        };
        const appId = 'vocabulary-29bb0';
        const initialAuthToken = null;

        // Firestore Collection Paths
        const PUBLIC_LIBRARIES_COLLECTION = `artifacts/${appId}/public/data/wordLibraries`;
        const PUBLIC_SUBSETS_COLLECTION = `artifacts/${appId}/public/data/wordSubsets`;
        const PUBLIC_WORDS_COLLECTION = `artifacts/${appId}/public/data/libraryWords`;
        const USER_SESSIONS_COLLECTION_BASE = `artifacts/${appId}/users/`; 
        const TYPING_SCORES_DOC = `artifacts/${appId}/public/data/typingScores/top5`;


        // Global variables for word library feature
        let allLibraries = [];
        let allSubsets = [];
        let allWordsFromLibrary = []; // Holds all words from all libraries for random selection
        let selectedLibraryId = null;
        let selectedLibraryName = null;
        let selectedSubsetId = null;
        let selectedSubsetName = null;
        let allWordsInCurrentLibrary = []; 

        // Global variables for quiz and other features
        let words = []; 
        let wrongWordsCurrentSession = []; 
        let persistentWrongWords = []; 
        let currentWordIndex = 0;
        let score = 0;
        let selectedFile = null;
        let autoSpeakEnabled = true; 
        let googleTranslateTtsEnabled = false; 
        
        // --- Audio Caching and Player ---
        let audioCache = new Map();
        const audioPlayer = new Audio();
        let isAudioContextUnlocked = false;
        let errorSoundBuffer = null;
        let audioContext;


        // --- Timer variables ---
        let wordStartTime = 0;
        let quizStartTime = null;

        // Session tracking variables
        let allPracticeSessions = [];
        let currentQuizDetails = {};
        
        // Flashcard variables
        let currentFlashcardIndex = 0;
        
        // MC Quiz variables
        let currentMcQuizIndex = 0;

        // --- NEW: Typing Practice variables ---
        const alphabet = 'abcdefghijklmnopqrstuvwxyz';
        let currentTargetCharIndex = 0;
        let typingStartTime = 0;
        let isTypingPracticeActive = false;
        let waitingForRestart = true;
        let bestTypingScores = [];
        
        // UPDATED: Recalibrated key coordinates
        const keyCoordinates = {
            'q': { top: 18.0, left: 9.5 }, 'w': { top: 18.0, left: 16.5 }, 'e': { top: 18.0, left: 22.5 }, 'r': { top: 18.0, left: 29.0 }, 't': { top: 18.0, left: 36.0 }, 'y': { top: 18.0, left: 42.5 }, 'u': { top: 18.0, left: 49.5 }, 'i': { top: 18.0, left: 56.5 }, 'o': { top: 18.0, left: 62.5 }, 'p': { top: 18.0, left: 69.5 },
            'a': { top: 37.0, left: 11.0 }, 's': { top: 37.0, left: 17.5 }, 'd': { top: 37.0, left: 24.0 }, 'f': { top: 37.0, left: 31.0 }, 'g': { top: 37.0, left: 37.0 }, 'h': { top: 37.0, left: 44.0 }, 'j': { top: 37.0, left: 51.0 }, 'k': { top: 37.0, left: 57.5 }, 'l': { top: 37.0, left: 64.0 },
            'z': { top: 57.0, left: 14.5 }, 'x': { top: 57.0, left: 21.0 }, 'c': { top: 57.0, left: 27.5 }, 'v': { top: 57.0, left: 34.5 }, 'b': { top: 57.0, left: 41.0 }, 'n': { top: 57.0, left: 48.0 }, 'm': { top: 57.0,  left: 54.5 }
        };

        // Get all necessary HTML elements
        const setupSection = document.getElementById('setup-section');
        const quizSection = document.getElementById('quiz-section');
        const completionSection = document.getElementById('completion-section');
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        
        const modeSelectionSection = document.getElementById('mode-selection-section');
        const modeSelectionWordCount = document.getElementById('mode-selection-word-count');
        const modeSelectFlashcard = document.getElementById('mode-select-flashcard');
        const modeSelectPractice = document.getElementById('mode-select-practice');
        const modeSelectBack = document.getElementById('mode-select-back');
        
        const flashcardSection = document.getElementById('flashcard-section');
        const flashcardProgress = document.getElementById('flashcard-progress');
        const flashcardBackToMenuButton = document.getElementById('flashcard-back-to-menu-button');
        const flashcardSpinner = document.querySelector('.flashcard .spinner-container');
        const flashcardContent = document.getElementById('flashcard-content');
        const flashcardWord = document.getElementById('flashcard-word');
        const flashcardPos = document.getElementById('flashcard-pos');
        const flashcardChinese = document.getElementById('flashcard-chinese');
        const flashcardExampleEng = document.querySelector('#flashcard-example .eng');
        const flashcardExampleChn = document.querySelector('#flashcard-example .chn');
        const flashcardSpeakButton = document.getElementById('flashcard-speak-button');
        const flashcardNav = document.getElementById('flashcard-nav');
        const flashcardPrevButton = document.getElementById('flashcard-prev-button');
        const flashcardNextButton = document.getElementById('flashcard-next-button');
        const flashcardCompletionOptions = document.getElementById('flashcard-completion-options');
        const flashcardFinishPracticeButton = document.getElementById('flashcard-finish-practice-button');
        const flashcardFinishMenuButton = document.getElementById('flashcard-finish-menu-button');

        const newWordsInputArea = document.getElementById('new-words-input-area');
        const wordInput = document.getElementById('word-input');
        const selectFileButton = document.getElementById('select-file-button');
        const uploadConfirmButton = document.getElementById('upload-confirm-button');
        const uploadStatus = document.getElementById('upload-status');
        const fileUpload = document.getElementById('file-upload');
        const startButton = document.getElementById('start-button');
        const autoSpeakCheckbox = document.getElementById('auto-speak-checkbox'); 
        const googleTtsCheckbox = document.getElementById('google-tts-checkbox');
        const newWordsRadio = document.getElementById('new-words-radio'); 
        const wrongWordsRadio = document.getElementById('wrong-words-radio'); 
        const wrongWordsCountSpan = document.getElementById('wrong-words-count');
        const wordLibraryRadio = document.getElementById('word-library-radio');
        const mcQuizRadio = document.getElementById('mc-quiz-radio');
        const typingPracticeRadio = document.getElementById('typing-practice-radio');
        const simpleModeArea = document.getElementById('simple-mode-area');
        const commonSettings = document.getElementById('common-settings');


        const progressText = document.getElementById('progress');
        const backToMenuButton = document.getElementById('back-to-menu-button');
        const chinesePrompt = document.getElementById('chinese-prompt');
        const englishInput = document.getElementById('english-input');
        const feedback = document.getElementById('feedback');
        const checkButton = document.getElementById('check-button');
        const nextButton = document.getElementById('next-button');
        const speakAgainButton = document.getElementById('speak-again-button'); 

        const scoreDisplay = document.getElementById('score-display');
        const wrongWordsList = document.getElementById('wrong-words-list');
        const restartButton = document.getElementById('restart-button');

        const inlineWrongWordsSelection = document.getElementById('inline-wrong-words-selection');
        const inlineWrongWordsSessionsList = document.getElementById('inline-wrong-words-sessions-list');

        const messageDialog = document.getElementById('message-dialog');
        const messageDialogText = document.getElementById('message-dialog-text');
        const messageDialogCloseButton = document.getElementById('message-dialog-close-button');

        const exampleSentenceContainer = document.getElementById('example-sentence-container');
        const englishExampleSentence = document.getElementById('english-example-sentence');
        const chineseExampleSentence = document.getElementById('chinese-example-sentence');

        const wordLibrarySelectionArea = document.getElementById('word-library-selection-area');
        const selectedLibraryDisplay = document.getElementById('selected-library-display');
        const selectLibraryForPracticeButton = document.getElementById('select-library-for-practice-button'); 
        const openManageModalButton = document.getElementById('open-manage-modal-button'); 

        const wordLibraryModal = document.getElementById('word-library-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalCloseButton = document.getElementById('modal-close-button');
        
        const manageView = document.getElementById('manage-view');
        const selectView = document.getElementById('select-view');
        const librarySelectionTree = document.getElementById('library-selection-tree');
        const selectedWordCountSpan = document.getElementById('selected-word-count');
        const confirmLibrarySelectionButton = document.getElementById('confirm-library-selection-button');

        const newLibraryNameInput = document.getElementById('new-library-name-input');
        const createLibraryButton = document.getElementById('create-library-button');
        const librariesList = document.getElementById('libraries-list');
        const subsetManagementSection = document.getElementById('subset-management-section');
        const currentLibraryNameSpan = document.getElementById('current-library-name');
        const newSubsetNameInput = document.getElementById('new-subset-name-input');
        const createSubsetButton = document.getElementById('create-subset-button');
        const subsetsList = document.getElementById('subsets-list');
        const wordsManagementSection = document.getElementById('words-management-section');
        const currentSubsetNameSpan = document.getElementById('current-subset-name');
        const subsetWordsInput = document.getElementById('subset-words-input');
        const saveSubsetWordsButton = document.getElementById('save-subset-words-button');
        const selectSubsetFileButton = document.getElementById('select-subset-file-button');
        const uploadSubsetConfirmButton = document.getElementById('upload-subset-confirm-button');
        const subsetUploadStatus = document.getElementById('subset-upload-status');
        const subsetFileUpload = document.getElementById('subset-file-upload');
        
        // MC Quiz Elements
        const multipleChoiceSetupArea = document.getElementById('multiple-choice-setup-area');
        const mcSourceRadios = document.querySelectorAll('input[name="mc-source"]');
        const mcRandomOptions = document.getElementById('mc-random-options');
        const mcManualOptions = document.getElementById('mc-manual-options');
        const randomWordCountInput = document.getElementById('random-word-count-input');
        const totalWordCountSpan = document.getElementById('total-word-count');
        const selectMcWordsButton = document.getElementById('select-mc-words-button');
        const mcSelectedDisplay = document.getElementById('mc-selected-display');
        
        const mcQuizSection = document.getElementById('mc-quiz-section');
        const mcProgress = document.getElementById('mc-progress');
        const mcBackToMenuButton = document.getElementById('mc-back-to-menu-button');
        const mcSpeakButton = document.getElementById('mc-speak-button');
        const mcOptionsContainer = document.getElementById('mc-options-container');
        const mcFeedback = document.getElementById('mc-feedback');
        const mcNextButton = document.getElementById('mc-next-button');

        // NEW: Typing Practice Elements
        const typingPracticeSection = document.getElementById('typing-practice-section');
        const nextCharIndicator = document.getElementById('next-char-indicator');
        const typingInfo = document.getElementById('typing-info');
        const leaderboardList = document.getElementById('leaderboard-list');
        const typingBackButton = document.getElementById('typing-back-button');


        // --- Firebase Initialization & Data Loading ---
        const initFirebase = async () => {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }
                    isAuthReady = true;
                    console.log("Firebase Ready. User ID:", userId);
                    loadPracticeSessionsFromFirestore();
                    loadAllWordsFromLibrary(); // Load all words for MC quiz random mode
                    loadTypingScoresFromFirestore(); // Load typing scores
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showMessage("Firebase 初始化失败。单词库和排行榜功能将不可用。");
                isAuthReady = true; 
            }
        };
        
        const loadAllWordsFromLibrary = async () => {
             if (!isAuthReady) return;
             try {
                const wordsSnapshot = await getDocs(query(collection(db, PUBLIC_WORDS_COLLECTION)));
                allWordsFromLibrary = wordsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                totalWordCountSpan.textContent = allWordsFromLibrary.length;
                console.log(`Loaded ${allWordsFromLibrary.length} total words from library.`);
             } catch (e) {
                console.error("Error loading all words from library:", e);
                totalWordCountSpan.textContent = 'N/A';
             }
        };

        initFirebase();


        // --- Gemini API Configuration ---
        const API_KEY = "AIzaSyB-TiVpLppqHtLUzsbip9YvYI82Tdqq-6E"; 
        const API_URL_TEXT = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
        
        // --- Custom Message Dialog Function ---
        const showMessage = (message) => {
            messageDialogText.innerHTML = message;
            messageDialog.style.display = 'flex';
        };

        messageDialogCloseButton.addEventListener('click', () => {
            messageDialog.style.display = 'none';
        });

        // --- Audio Context Unlock & Sound Generation ---
        const unlockAudioContext = () => {
            if (isAudioContextUnlocked || !window.AudioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const silentAudio = new Audio("data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhIAAAAAA=");
                silentAudio.play().then(() => {
                    isAudioContextUnlocked = true;
                    console.log("Audio context unlocked successfully.");
                    preloadErrorSound(); // Preload sound after context is unlocked
                }).catch(error => {
                    console.warn("Could not unlock audio context on first try:", error);
                });
            } catch (e) {
                console.error("Could not create AudioContext:", e);
            }
        };
        
        const preloadErrorSound = () => {
            if (errorSoundBuffer || !audioContext) return;
            let oscillator = audioContext.createOscillator();
            let gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01);
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A low pitch
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.2);
            
            // This doesn't create a reusable buffer, but it's a simple way to define the sound
            // For a true buffer, we'd use createBuffer and fill it with data.
            // This is a simplified approach for this use case.
            // The actual playing will be done in playErrorSound.
            console.log("Error sound pre-configured.");
        };

        const playErrorSound = () => {
            if (!audioContext || !isAudioContextUnlocked) {
                console.warn("Audio context not ready, cannot play error sound.");
                return;
            }
            let oscillator = audioContext.createOscillator();
            let gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01); // Lower volume
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
            oscillator.type = 'triangle'; // Softer tone

            oscillator.start(audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.2);
            oscillator.stop(audioContext.currentTime + 0.2);
        };


        // --- Firestore-based Session Management Functions ---
        const loadPracticeSessionsFromFirestore = async () => {
            if (!isAuthReady || !userId) return;
            showLoader('正在加载错题记录...');
            try {
                const sessionsCollectionPath = `${USER_SESSIONS_COLLECTION_BASE}${userId}/practiceSessions`;
                const q = query(collection(db, sessionsCollectionPath), orderBy("endTime", "desc"));
                const querySnapshot = await getDocs(q);

                allPracticeSessions = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                const overallUniqueWrongWordsMap = new Map();
                allPracticeSessions.forEach(session => {
                    if(session.sessionWords && Array.isArray(session.sessionWords)) {
                        session.sessionWords.forEach(word => {
                            if (!word.wasCorrect) {
                                if (!overallUniqueWrongWordsMap.has(word.english) || overallUniqueWrongWordsMap.get(word.english).timestamp < session.endTime.toMillis()) {
                                    overallUniqueWrongWordsMap.set(word.english, {
                                        english: word.english,
                                        chinese: word.chinese,
                                        timestamp: session.endTime.toMillis()
                                    });
                                }
                            }
                        });
                    }
                });
                persistentWrongWords = Array.from(overallUniqueWrongWordsMap.values());
                wrongWordsCountSpan.textContent = persistentWrongWords.length;
                wrongWordsRadio.disabled = persistentWrongWords.length === 0;

            } catch (error) {
                console.error("Error loading practice sessions from Firestore:", error);
                showMessage("加载错题记录失败。请检查您的网络连接。");
            } finally {
                hideLoader();
                updateStartButtonState();
            }
        };

        const savePracticeSessionToFirestore = async () => {
            if (!isAuthReady || !userId || words.length === 0) return;

            const quizEndTime = new Date();
            const totalDurationSeconds = (quizEndTime - quizStartTime) / 1000;
            const accuracy = score / words.length;

            const sessionData = {
                ...currentQuizDetails,
                userId: userId,
                startTime: quizStartTime,
                endTime: quizEndTime,
                totalDurationSeconds: totalDurationSeconds,
                score: score,
                totalWords: words.length,
                accuracy: accuracy,
                sessionWords: words.map(w => ({
                    english: w.english,
                    chinese: w.chinese,
                    wasCorrect: w.wasCorrect || false,
                    timeTakenSeconds: w.timeTakenSeconds || 0
                }))
            };

            try {
                const sessionsCollectionPath = `${USER_SESSIONS_COLLECTION_BASE}${userId}/practiceSessions`;
                await addDoc(collection(db, sessionsCollectionPath), sessionData);
                console.log("Practice session saved to Firestore.");
            } catch (error) {
                console.error("Error saving practice session to Firestore:", error);
                showMessage("无法保存本次练习记录，请检查网络。");
            } finally {
                await loadPracticeSessionsFromFirestore();
            }
        };


        // --- Utility Functions ---
        const showLoader = (text) => { loaderText.textContent = text; loader.style.display = 'flex'; };
        const hideLoader = () => { loader.style.display = 'none'; };
        const fileToBase64 = (file) => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = error => reject(error);
        });

        const parseWordInput = (text) => {
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            return lines.map(line => {
                const parts = line.split(/[-=＝－]/).map(part => part.trim()); // Split by various delimiters
                if (parts.length >= 2 && parts[0] && parts[1]) {
                    return { english: parts[0], chinese: parts[1] };
                } else if (parts.length === 1 && parts[0]) {
                    return { english: parts[0], chinese: null };
                }
                return null;
            }).filter(Boolean);
        };

        // --- Audio Pre-fetch Function ---
        const prefetchAudio = async (word) => {
            if (audioCache.has(word) || !googleTranslateTtsEnabled) return;
            try {
                const targetUrl = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(word)}&tl=en&client=tw-ob`;
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`;
                
                const response = await fetch(proxyUrl);
                if (!response.ok) throw new Error('获取音频文件失败: ' + response.statusText);
                const audioBlob = await response.blob();
                audioCache.set(word, audioBlob);
                console.log(`音频 "${word}" 已被预加载和缓存。`);
            } catch (error) {
                console.error(`无法预加载音频 "${word}":`, error);
            }
        };

        const speak = async (text) => {
            if (!audioPlayer.paused) audioPlayer.pause();
            unlockAudioContext();

            if (googleTranslateTtsEnabled) {
                let audioBlob = audioCache.get(text);
                if (!audioBlob) {
                    try {
                        const targetUrl = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(text)}&tl=en&client=tw-ob`;
                        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`;
                        const response = await fetch(proxyUrl);
                        if (!response.ok) throw new Error('获取音频文件失败');
                        audioBlob = await response.blob();
                        audioCache.set(text, audioBlob);
                    } catch (error) {
                        console.error("播放 Google TTS 音频时出错:", error);
                        showMessage("无法加载单词发音，请检查网络连接。");
                        return;
                    }
                }
                const audioUrl = URL.createObjectURL(audioBlob);
                audioPlayer.src = audioUrl;
                audioPlayer.play().catch(e => console.error("音频播放失败:", e));
            } else if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                utterance.rate = 0.9;
                window.speechSynthesis.speak(utterance);
            } else {
                showMessage('您的浏览器不支持语音功能。');
            }
        };

        // --- Gemini API Calls ---
        const extractTextFromFile = async (base64Data, mimeType) => {
            const payload = {
                contents: [{
                    parts: [
                        { text: "Extract all text from the provided file. If the file contains English words, with or without Chinese translations, list them in a clean format (e.g., one word or 'English - Chinese' pair per line). If no clear word pairs are found, return the raw text content." },
                        { inlineData: { mimeType: mimeType, data: base64Data } }
                    ]
                }]
            };
            const response = await fetch(API_URL_TEXT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`Gemini API Error: ${response.statusText}`);
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) throw new Error("Could not extract text from the file.");
            return text;
        };

        const callGeminiForTranslation = async (englishWordsOnly) => {
            const prompt = `Translate the following English words to Chinese. Provide the response as a valid JSON array of objects, where each object has 'english' and 'chinese' keys. Words: ${JSON.stringify(englishWordsOnly)}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "OBJECT", properties: { "english": { "type": "STRING" }, "chinese": { "type": "STRING" } }, required: ["english", "chinese"] } } }
            };
            const response = await fetch(API_URL_TEXT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not get translations.");
            return JSON.parse(jsonText);
        };

        const callGeminiForVerification = async (wordsWithProvidedChinese) => {
            const formattedWords = wordsWithProvidedChinese.map(w => ({ english: w.english, provided_chinese: w.chinese }));
            const prompt = `For each English word and its provided Chinese translation, indicate if the translation is accurate. If not, provide the correct translation. Format the response as a valid JSON array of objects, where each object has 'english', 'provided_chinese', 'is_accurate' (boolean), and 'correct_chinese' (string, only if not accurate). Words: ${JSON.stringify(formattedWords)}`;
            
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { 
                    responseMimeType: "application/json", 
                    responseSchema: { 
                        type: "ARRAY", 
                        items: { 
                            type: "OBJECT", 
                            properties: { 
                                "english": { "type": "STRING" }, 
                                "provided_chinese": { "type": "STRING" },
                                "is_accurate": { "type": "BOOLEAN" },
                                "correct_chinese": { "type": "STRING" } 
                            }, 
                            required: ["english", "provided_chinese", "is_accurate"] 
                        } 
                    } 
                }
            };
            const response = await fetch(API_URL_TEXT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not get verification results.");
            return JSON.parse(jsonText);
        };

        const callGeminiForExampleSentenceAndTranslation = async (englishWord) => {
            const prompt = `Please generate a simple and common English example sentence for the word '${englishWord}'. Immediately after the English sentence, provide its Chinese translation. Format the response as a JSON object with 'englishSentence' and 'chineseSentence' keys.`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "englishSentence": { "type": "STRING" },
                            "chineseSentence": { "type": "STRING" }
                        },
                        required: ["englishSentence", "chineseSentence"]
                    }
                }
            };
            const response = await fetch(API_URL_TEXT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not generate example sentence and translation.");
            return JSON.parse(jsonText);
        };

        const callGeminiForFlashcardData = async (englishWord) => {
            const prompt = `For the English word "${englishWord}", provide the following information:
1.  The word with syllable breaks (using a hyphen, e.g., "beau-ti-ful").
2.  The primary part of speech (e.g., "noun", "verb", "adjective").
3.  The Chinese translation.
4.  A simple English example sentence.
5.  The Chinese translation of the example sentence.

Format the response as a single, valid JSON object with these exact keys: "syllables", "partOfSpeech", "chinese", "englishSentence", "chineseSentence".`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "syllables": { "type": "STRING" },
                            "partOfSpeech": { "type": "STRING" },
                            "chinese": { "type": "STRING" },
                            "englishSentence": { "type": "STRING" },
                            "chineseSentence": { "type": "STRING" }
                        },
                        required: ["syllables", "partOfSpeech", "chinese", "englishSentence", "chineseSentence"]
                    }
                }
            };
             const response = await fetch(API_URL_TEXT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not generate flashcard data.");
            return JSON.parse(jsonText);
        };
        
        const callGeminiForMcqOptions = async (correctWord, allQuizWords) => {
            const prompt = `For a multiple-choice question, the correct answer is "${correctWord}". 
Please generate three incorrect options (distractors).
1.  One distractor should be a real English word that looks or sounds similar to "${correctWord}".
2.  The other two distractors should be common, real English words.
3.  None of the distractors should be any of these words: ${JSON.stringify(allQuizWords)}.

Provide the response as a single, valid JSON object with these exact keys: "similar", "random1", "random2".`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "similar": { "type": "STRING" },
                            "random1": { "type": "STRING" },
                            "random2": { "type": "STRING" }
                        },
                        required: ["similar", "random1", "random2"]
                    }
                }
            };
            const response = await fetch(API_URL_TEXT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not generate MCQ options.");
            return JSON.parse(jsonText);
        };


        const processWordsForQuiz = async (inputWords) => {
            const wordsWithoutChinese = inputWords.filter(w => !w.chinese);
            const wordsWithChinese = inputWords.filter(w => w.chinese);

            let translatedWords = [];
            let wordsToReturn = [...wordsWithChinese]; 

            if (wordsWithoutChinese.length > 0) {
                showLoader('正在翻译新单词...');
                const englishOnlyList = wordsWithoutChinese.map(w => w.english);
                try {
                    translatedWords = await callGeminiForTranslation(englishOnlyList);
                    wordsToReturn = [...wordsToReturn, ...translatedWords];
                } catch (error) {
                    console.error("翻译新单词时出错:", error);
                    showMessage("翻译新单词时发生错误，请检查网络或重试。");
                    return [];
                }
            }

            if (wordsWithChinese.length > 0) {
                showLoader('正在验证已有翻译...');
                try {
                    const verifiedResults = await callGeminiForVerification(wordsWithChinese);
                    
                    verifiedResults.forEach(verifiedWord => {
                        if (!verifiedWord.is_accurate) {
                            const message = `翻译不准确：<br>英文: <strong>${verifiedWord.english}</strong><br>您提供的中文: <strong>${verifiedWord.provided_chinese}</strong><br>正确翻译应为: <strong>${verifiedWord.correct_chinese}</strong>。已自动更新。`;
                            showMessage(message);
                            const wordInList = wordsToReturn.find(w => w.english === verifiedWord.english);
                            if (wordInList) {
                                wordInList.chinese = verifiedWord.correct_chinese;
                            }
                        }
                    });
                } catch (error) {
                    console.error("验证已有翻译时出错:", error);
                    showMessage("验证已有翻译时发生错误，将使用您提供的翻译。");
                }
            }

            const finalWordsMap = new Map();
            wordsToReturn.forEach(word => {
                finalWordsMap.set(word.english.toLowerCase(), word);
            });

            return Array.from(finalWordsMap.values());
        };


        // --- Main Application Flow ---
        const startQuiz = () => {
            if (words.length === 0) {
                showMessage('没有可供练习的单词。');
                return;
            }

            quizStartTime = new Date();
            currentWordIndex = 0;
            score = 0;
            
            currentQuizDetails = { practiceMode: '单词拼写' };
            if (wrongWordsRadio.checked) {
                currentQuizDetails.practiceMode = '错题练习';
            } else if (wordLibraryRadio.checked) {
                currentQuizDetails.practiceMode = '单词库拼写';
            }
            
            words.forEach(word => {
                word.wasCorrect = false;
                word.timeTakenSeconds = 0;
            });
            
            shuffleArray(words);
            
            setupSection.style.display = 'none';
            completionSection.style.display = 'none';
            flashcardSection.style.display = 'none';
            modeSelectionSection.style.display = 'none';
            mcQuizSection.style.display = 'none';
            typingPracticeSection.style.display = 'none';
            quizSection.style.display = 'block';

            showNextWord();
        };

        // --- Quiz Logic ---
        const checkAnswer = async () => {
            const timeTakenSeconds = (performance.now() - wordStartTime) / 1000;
            words[currentWordIndex].timeTakenSeconds = timeTakenSeconds;

            const userAnswer = englishInput.value.trim().toLowerCase();
            const correctAnswer = words[currentWordIndex].english.toLowerCase();
            
            if (userAnswer === '') {
                feedback.textContent = '请输入答案！';
                feedback.className = '';
                return;
            }

            if (userAnswer === correctAnswer) {
                score++;
                words[currentWordIndex].wasCorrect = true;
                feedback.innerHTML = `✔ 正确! <span style="font-size: 0.8em; color: #555;">(${timeTakenSeconds.toFixed(2)}s)</span>`;
                feedback.className = 'correct';
            } else {
                words[currentWordIndex].wasCorrect = false;
                const currentWord = words[currentWordIndex];
                feedback.innerHTML = `❌ 错误！正确答案是: <strong style="color: #333;">${currentWord.english}</strong> <span style="font-size: 0.8em; color: #555;">(${timeTakenSeconds.toFixed(2)}s)</span>`;
                feedback.className = 'incorrect';
            }

            englishInput.disabled = true;
            checkButton.style.display = 'none';
            nextButton.style.display = 'block';
            nextButton.focus();

            showLoader('正在生成例句...');
            try {
                const exampleData = await callGeminiForExampleSentenceAndTranslation(words[currentWordIndex].english);
                englishExampleSentence.textContent = exampleData.englishSentence;
                chineseExampleSentence.textContent = exampleData.chineseSentence;
                exampleSentenceContainer.style.display = 'block';
            } catch (error) {
                console.error("生成例句时出错:", error);
                exampleSentenceContainer.style.display = 'none';
            } finally {
                hideLoader();
            }
        };

        const showNextWord = () => {
            exampleSentenceContainer.style.display = 'none';
            englishExampleSentence.textContent = '';
            chineseExampleSentence.textContent = '';

            if (currentWordIndex < words.length) {
                const word = words[currentWordIndex];
                progressText.textContent = `第 ${currentWordIndex + 1} / ${words.length} 题`;
                chinesePrompt.textContent = word.chinese;
                englishInput.placeholder = '_ '.repeat(word.english.length).trim();
                englishInput.value = '';
                englishInput.disabled = false;
                feedback.textContent = '';
                feedback.className = '';
                checkButton.style.display = 'block';
                nextButton.style.display = 'none';
                englishInput.focus();
                
                wordStartTime = performance.now();
                
                if (autoSpeakEnabled) {
                    speak(word.english);
                }
                
                if (currentWordIndex + 1 < words.length) {
                    prefetchAudio(words[currentWordIndex + 1].english);
                }

            } else {
                showCompletionScreen();
            }
        };

        const showCompletionScreen = async () => {
            // Only save session if it was a word-based quiz
            if (currentQuizDetails.practiceMode) {
                await savePracticeSessionToFirestore();
            }

            quizSection.style.display = 'none';
            mcQuizSection.style.display = 'none';
            completionSection.style.display = 'block';
            
            const totalDurationSeconds = words.length > 0 ? (new Date() - quizStartTime) / 1000 : 0;
            const averageTimePerWord = words.length > 0 ? words.reduce((acc, word) => acc + (word.timeTakenSeconds || 0), 0) / words.length : 0;
            const percentage = words.length > 0 ? Math.round((score / words.length) * 100) : 0;
            
            scoreDisplay.innerHTML = `你答对了 <strong>${score}</strong> 道题，共 <strong>${words.length}</strong> 道。<br>正确率: <strong>${percentage}%</strong><br>总用时: <strong>${totalDurationSeconds.toFixed(2)}</strong> 秒<br>平均用时: <strong>${averageTimePerWord.toFixed(2)}</strong> 秒/词`;
            
            wrongWordsList.innerHTML = '';
            const sessionWrongWords = words.filter(word => !word.wasCorrect);

            if (sessionWrongWords.length > 0) {
                let html = '<h3>本次错题：</h3><ul>';
                sessionWrongWords.forEach(word => {
                    html += `<li><strong>${word.english}</strong>: ${word.chinese} (${(word.timeTakenSeconds || 0).toFixed(2)}s)</li>`;
                });
                html += '</ul>';
                wrongWordsList.innerHTML = html;
            } else {
                if (words.length > 0 && score === words.length) {
                     wrongWordsList.innerHTML = '<p style="color: #28a745; font-weight: bold;">太棒了，全部正确！</p>';
                } else {
                     wrongWordsList.innerHTML = '<p style="color: #6c757d; font-weight: bold;">本次练习没有错题。</p>';
                }
            }
        };


        checkButton.addEventListener('click', checkAnswer);
        englishInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter' && !englishInput.disabled) checkAnswer();
        });
        nextButton.addEventListener('click', () => {
            currentWordIndex++;
            showNextWord();
        });
        speakAgainButton.addEventListener('click', () => {
            if(currentWordIndex < words.length) {
                speak(words[currentWordIndex].english);
            }
        });
        backToMenuButton.addEventListener('click', () => {
            showCompletionScreen();
        });

        // --- Flashcard Logic ---
        const startFlashcards = () => {
            unlockAudioContext();
            autoSpeakEnabled = autoSpeakCheckbox.checked;
            currentFlashcardIndex = 0;
            
            modeSelectionSection.style.display = 'none';
            flashcardSection.style.display = 'flex';
            flashcardCompletionOptions.style.display = 'none';
            flashcardNav.style.display = 'flex';
            
            showFlashcard(currentFlashcardIndex);
        };

        const showFlashcard = async (index) => {
            if (index >= words.length) {
                // Review is complete
                flashcardNav.style.display = 'none';
                flashcardCompletionOptions.style.display = 'flex';
                flashcardContent.style.display = 'none';
                flashcardProgress.textContent = `复习完毕 (${words.length} / ${words.length})`;
                return;
            }

            flashcardProgress.textContent = `单词卡 ${index + 1} / ${words.length}`;
            flashcardPrevButton.disabled = (index === 0);
            flashcardNextButton.textContent = (index === words.length - 1) ? '完成复习' : '下一个';

            const currentWord = words[index];
            
            if (currentWord.flashcardData) {
                populateFlashcard(currentWord.flashcardData);
                if (autoSpeakEnabled) speak(currentWord.english);
                return;
            }

            flashcardSpinner.style.display = 'flex';
            flashcardContent.style.display = 'none';
            try {
                const data = await callGeminiForFlashcardData(currentWord.english);
                data.chinese = currentWord.chinese || data.chinese;
                currentWord.flashcardData = data; // Cache the data
                populateFlashcard(data);
                if (autoSpeakEnabled) speak(currentWord.english);
            } catch (error) {
                console.error("Error fetching flashcard data:", error);
                showMessage(`无法加载单词 "${currentWord.english}" 的详细信息。`);
                populateFlashcard({
                    syllables: currentWord.english,
                    partOfSpeech: 'N/A',
                    chinese: currentWord.chinese,
                    englishSentence: 'Could not load example.',
                    chineseSentence: '无法加载例句。'
                });
            } finally {
                flashcardSpinner.style.display = 'none';
                flashcardContent.style.display = 'block';
            }
        };

        const populateFlashcard = (data) => {
            flashcardWord.textContent = data.syllables;
            flashcardPos.textContent = data.partOfSpeech;
            flashcardChinese.textContent = data.chinese;
            flashcardExampleEng.textContent = data.englishSentence;
            flashcardExampleChn.textContent = data.chineseSentence;
        };

        flashcardPrevButton.addEventListener('click', () => {
            if (currentFlashcardIndex > 0) {
                currentFlashcardIndex--;
                showFlashcard(currentFlashcardIndex);
            }
        });

        flashcardNextButton.addEventListener('click', () => {
            currentFlashcardIndex++;
            showFlashcard(currentFlashcardIndex);
        });

        flashcardSpeakButton.addEventListener('click', () => {
            if (currentFlashcardIndex < words.length) {
                speak(words[currentFlashcardIndex].english);
            }
        });

        flashcardFinishPracticeButton.addEventListener('click', startQuiz);
        flashcardBackToMenuButton.addEventListener('click', () => { restartButton.click(); });
        flashcardFinishMenuButton.addEventListener('click', () => { restartButton.click(); });

        // --- Multiple Choice Quiz Logic ---
        const startMcQuiz = async () => {
            if (words.length === 0) {
                showMessage('没有可供练习的单词。');
                return;
            }

            showLoader('正在为选择题生成选项和翻译...');
            const allQuizWords = words.map(w => w.english);
            try {
                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    if (!word.mcOptions) { // Only fetch if not already fetched
                        // 1. Get English distractors
                        const distractorsResult = await callGeminiForMcqOptions(word.english, allQuizWords);
                        const distractorWords = [distractorsResult.similar, distractorsResult.random1, distractorsResult.random2];

                        // 2. Get translations for distractors
                        const translatedDistractors = await callGeminiForTranslation(distractorWords);
                        
                        // Create a map for easy lookup
                        const translationMap = new Map();
                        translatedDistractors.forEach(t => translationMap.set(t.english.toLowerCase(), t.chinese));

                        // 3. Build the final options array with objects
                        const finalOptions = [];
                        // Add correct answer
                        finalOptions.push({ english: word.english, chinese: word.chinese });
                        // Add distractors with their translations
                        distractorWords.forEach(distractor => {
                            finalOptions.push({
                                english: distractor,
                                chinese: translationMap.get(distractor.toLowerCase()) || '...'
                            });
                        });
                        
                        word.mcOptions = finalOptions;
                    }
                }
            } catch (error) {
                console.error("Error generating MCQ options:", error);
                showMessage("生成选择题选项时出错，请稍后重试。");
                hideLoader();
                return;
            }
            hideLoader();

            quizStartTime = new Date();
            currentMcQuizIndex = 0;
            score = 0;
            currentQuizDetails = { practiceMode: '单词选择题' };
            
            words.forEach(word => {
                word.wasCorrect = false;
                word.timeTakenSeconds = 0;
            });
            
            shuffleArray(words);
            
            setupSection.style.display = 'none';
            completionSection.style.display = 'none';
            flashcardSection.style.display = 'none';
            modeSelectionSection.style.display = 'none';
            quizSection.style.display = 'none';
            typingPracticeSection.style.display = 'none';
            mcQuizSection.style.display = 'block';

            showNextMcQuestion();
        };

        const showNextMcQuestion = () => {
            if (currentMcQuizIndex >= words.length) {
                showCompletionScreen();
                return;
            }

            const word = words[currentMcQuizIndex];
            mcProgress.textContent = `第 ${currentMcQuizIndex + 1} / ${words.length} 题`;
            mcFeedback.textContent = '';
            mcNextButton.style.display = 'none';
            
            mcOptionsContainer.innerHTML = '';
            const shuffledOptions = [...word.mcOptions];
            shuffleArray(shuffledOptions);

            shuffledOptions.forEach(option => {
                const button = document.createElement('button');
                // MODIFIED: Display both English and Chinese
                button.innerHTML = `${option.english}<br><span style="font-size: 0.8em; color: #666; font-weight: normal;">${option.chinese}</span>`;
                button.classList.add('mc-option-button');
                // MODIFIED: Dataset uses the English word for checking the answer
                button.dataset.word = option.english;
                mcOptionsContainer.appendChild(button);
                button.addEventListener('click', () => checkMcAnswer(button, word.english));
            });
            
            wordStartTime = performance.now();
            if(autoSpeakEnabled) {
                speak(word.english);
            }
        };
        
        const checkMcAnswer = (selectedButton, correctAnswer) => {
            const timeTakenSeconds = (performance.now() - wordStartTime) / 1000;
            const currentWord = words[currentMcQuizIndex];
            currentWord.timeTakenSeconds = timeTakenSeconds;

            const isCorrect = selectedButton.dataset.word.toLowerCase() === correctAnswer.toLowerCase();
            
            Array.from(mcOptionsContainer.children).forEach(button => {
                button.disabled = true;
                if (button.dataset.word.toLowerCase() === correctAnswer.toLowerCase()) {
                    button.classList.add('correct-answer');
                } else if (button === selectedButton) {
                    button.classList.add('wrong-answer');
                }
            });

            if (isCorrect) {
                score++;
                currentWord.wasCorrect = true;
                mcFeedback.innerHTML = `✔ 正确!`;
                mcFeedback.className = 'correct';
            } else {
                currentWord.wasCorrect = false;
                // MODIFIED: Show Chinese translation in the feedback for the correct answer
                mcFeedback.innerHTML = `❌ 错误！正确答案是: <strong>${currentWord.english}</strong> (${currentWord.chinese})`;
                mcFeedback.className = 'incorrect';
            }

            mcNextButton.style.display = 'block';
            mcNextButton.focus();
        };
        
        mcSpeakButton.addEventListener('click', () => {
            if (currentMcQuizIndex < words.length) {
                speak(words[currentMcQuizIndex].english);
            }
        });
        
        mcNextButton.addEventListener('click', () => {
            currentMcQuizIndex++;
            showNextMcQuestion();
        });

        mcBackToMenuButton.addEventListener('click', showCompletionScreen);

        // --- NEW: Typing Practice Logic ---
        const startTypingPractice = () => {
            unlockAudioContext(); // Ensure audio is ready
            setupSection.style.display = 'none';
            typingPracticeSection.style.display = 'flex';
            isTypingPracticeActive = true;
            waitingForRestart = true;
            typingInfo.innerHTML = `<p>请按 'a' 键开始新一轮练习</p>`;
            nextCharIndicator.style.display = 'none';
            document.addEventListener('keydown', handleTypingKeyPress);
        };

        const startNewTypingRound = () => {
            waitingForRestart = false;
            currentTargetCharIndex = 0;
            typingInfo.innerHTML = `<p>正在计时... 字母: <span style="color: #dc3545;">A</span></p>`;
            updateNextCharDisplay();
            typingStartTime = performance.now();
        };
        
        const endTypingRound = () => {
            isTypingPracticeActive = false; // Temporarily disable listener
            const endTime = performance.now();
            const elapsedTime = (endTime - typingStartTime) / 1000;
            
            let isNewRecord = bestTypingScores.length < 5 || elapsedTime < bestTypingScores[bestTypingScores.length - 1].score;
            
            let message = `🎉 太棒了！用时 <strong>${elapsedTime.toFixed(2)}</strong> 秒！`;
            if (isNewRecord) {
                message = `<span class="new-record">🏆 新纪录！太厉害了！用时 <strong>${elapsedTime.toFixed(2)}</strong> 秒！</span>`;
                saveTypingScoreToFirestore(elapsedTime);
            }
            message += `<br><span style="font-size: 0.8em; color: #666;">请按 'a' 键开始新一轮练习</span>`;
            
            typingInfo.innerHTML = message;
            nextCharIndicator.style.display = 'none';
            waitingForRestart = true;
            isTypingPracticeActive = true; // Re-enable listener
        };

        const handleTypingKeyPress = (event) => {
            if (!isTypingPracticeActive || event.key.length > 1) { // Ignore keys like Shift, Ctrl
                return;
            }
            
            const keyPressed = event.key.toLowerCase();

            if (waitingForRestart) {
                if (keyPressed === 'a') {
                    startNewTypingRound();
                }
                return;
            }

            const targetChar = alphabet[currentTargetCharIndex];
            if (keyPressed === targetChar) {
                currentTargetCharIndex++;
                if (currentTargetCharIndex < alphabet.length) {
                    updateNextCharDisplay();
                    const nextChar = alphabet[currentTargetCharIndex].toUpperCase();
                    typingInfo.innerHTML = `<p>正在计时... 字母: <span style="color: #dc3545;">${nextChar}</span></p>`;
                } else {
                    endTypingRound();
                }
            } else {
                playErrorSound();
            }
        };
        
        const updateNextCharDisplay = () => {
            const char = alphabet[currentTargetCharIndex];
            const coords = keyCoordinates[char];
            if (coords) {
                nextCharIndicator.textContent = char.toUpperCase();
                nextCharIndicator.style.top = `${coords.top}%`;
                nextCharIndicator.style.left = `${coords.left}%`;
                nextCharIndicator.style.display = 'flex';
            }
        };

        const loadTypingScoresFromFirestore = () => {
            if (!isAuthReady) return;
            const docRef = doc(db, TYPING_SCORES_DOC);
            onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    bestTypingScores = docSnap.data().scores || [];
                } else {
                    bestTypingScores = [];
                }
                displayLeaderboard();
            }, (error) => {
                console.error("Error loading typing scores:", error);
            });
        };

        const saveTypingScoreToFirestore = async (newScore) => {
            if (!isAuthReady) return;
            const newEntry = { score: newScore, date: new Date().toISOString().split('T')[0], user: userId.substring(0, 6) };
            let updatedScores = [...bestTypingScores, newEntry];
            updatedScores.sort((a, b) => a.score - b.score);
            if (updatedScores.length > 5) {
                updatedScores = updatedScores.slice(0, 5);
            }
            
            try {
                await setDoc(doc(db, TYPING_SCORES_DOC), { scores: updatedScores });
                console.log("Typing score saved successfully.");
            } catch (error) {
                console.error("Error saving typing score:", error);
            }
        };

        const displayLeaderboard = () => {
            leaderboardList.innerHTML = '';
            if (bestTypingScores.length === 0) {
                leaderboardList.innerHTML = '<li>暂无记录</li>';
                return;
            }
            bestTypingScores.forEach(entry => {
                const li = document.createElement('li');
                li.textContent = `${entry.score.toFixed(2)}s - by ${entry.user || 'anon'}`;
                leaderboardList.appendChild(li);
            });
        };
        
        typingBackButton.addEventListener('click', () => {
            isTypingPracticeActive = false;
            document.removeEventListener('keydown', handleTypingKeyPress);
            goBackToMainMenu();
        });


        const goBackToMainMenu = () => {
            completionSection.style.display = 'none';
            quizSection.style.display = 'none';
            flashcardSection.style.display = 'none';
            modeSelectionSection.style.display = 'none';
            mcQuizSection.style.display = 'none';
            typingPracticeSection.style.display = 'none';
            setupSection.style.display = 'block';
            
            words = [];
            wordInput.value = '';
            uploadStatus.textContent = '未选择任何文件';
            fileUpload.value = '';
            selectedFile = null;
            startButton.disabled = true;
            uploadConfirmButton.disabled = true;
            autoSpeakCheckbox.checked = true;
            autoSpeakEnabled = true;
            googleTtsCheckbox.checked = false;
            googleTranslateTtsEnabled = false;
            newWordsRadio.checked = true;
            
            audioCache.clear();

            loadPracticeSessionsFromFirestore();
            updatePracticeModeDisplay();
        };

        restartButton.addEventListener('click', goBackToMainMenu);

        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        };

        const updateStartButtonState = () => {
            let canStart = false;
            const selectedMode = document.querySelector('input[name="practice-mode"]:checked').value;

            switch(selectedMode) {
                case 'new-words':
                    canStart = wordInput.value.trim() !== '' || (selectedFile && !uploadConfirmButton.disabled);
                    break;
                case 'wrong-words':
                    const checkedSessions = inlineWrongWordsSelection.querySelectorAll('input[type="checkbox"]:checked');
                    canStart = checkedSessions.length > 0;
                    break;
                case 'word-library':
                    canStart = words.length > 0;
                    break;
                case 'mc-quiz':
                    const mcSource = document.querySelector('input[name="mc-source"]:checked').value;
                    if (mcSource === 'random') {
                        canStart = parseInt(randomWordCountInput.value) > 0 && allWordsFromLibrary.length > 0;
                    } else { // manual
                        canStart = words.length > 0;
                    }
                    break;
                case 'typing-practice':
                    canStart = true;
                    break;
            }
            startButton.disabled = !canStart;
        };

        const updatePracticeModeDisplay = () => {
            document.querySelectorAll('.mode-setup-section').forEach(el => el.style.display = 'none');
            const selectedMode = document.querySelector('input[name="practice-mode"]:checked').value;
            commonSettings.style.display = 'block'; // Show common settings by default
            
            switch(selectedMode) {
                case 'new-words':
                    newWordsInputArea.style.display = 'flex';
                    break;
                case 'wrong-words':
                    if (persistentWrongWords.length > 0) {
                        inlineWrongWordsSelection.style.display = 'flex';
                        showInlineWrongWordsSelection();
                    }
                    break;
                case 'word-library':
                    wordLibrarySelectionArea.style.display = 'flex';
                    updateSelectedLibraryDisplay();
                    break;
                case 'mc-quiz':
                    multipleChoiceSetupArea.style.display = 'flex';
                    updateMcSourceDisplay();
                    break;
                case 'typing-practice':
                    simpleModeArea.style.display = 'flex';
                    commonSettings.style.display = 'none'; // Hide settings not relevant to typing
                    break;
            }
            updateStartButtonState();
        };
        
        const updateMcSourceDisplay = () => {
            const mcSource = document.querySelector('input[name="mc-source"]:checked').value;
            if (mcSource === 'random') {
                mcRandomOptions.style.display = 'flex';
                mcManualOptions.style.display = 'none';
            } else {
                mcRandomOptions.style.display = 'none';
                mcManualOptions.style.display = 'block';
            }
            updateStartButtonState();
        };


        // --- Inline Wrong Words Selection Logic ---
        const showInlineWrongWordsSelection = () => {
            inlineWrongWordsSessionsList.innerHTML = '';
            if (allPracticeSessions && allPracticeSessions.length > 0) {
                allPracticeSessions.forEach(session => {
                    const wrongWordsInSession = session.sessionWords?.filter(w => !w.wasCorrect) || [];
                    if (wrongWordsInSession.length === 0) return;

                    const sessionItem = document.createElement('div');
                    sessionItem.classList.add('session-item');
                    sessionItem.dataset.sessionId = session.id;

                    const sessionHeader = document.createElement('div');
                    sessionHeader.classList.add('session-header');
                    
                    const sessionDate = session.endTime.toDate ? session.endTime.toDate().toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '未知日期';
                    const accuracyText = session.accuracy !== undefined ? `${(session.accuracy * 100).toFixed(0)}%` : 'N/A';
                    const modeText = session.practiceMode || '未知模式';
                    const libraryText = modeText === '单词库练习' && session.libraryInfo ? `(${session.libraryInfo.subsetName})` : '';

                    sessionHeader.innerHTML = `
                        <input type="checkbox" value="${session.id}">
                        <div class="session-info">
                            <strong>${sessionDate}</strong> (${wrongWordsInSession.length} 个错词, 正确率 ${accuracyText})
                            <span class="session-mode">${modeText} ${libraryText}</span>
                        </div>
                        <span class="toggle-icon">▶</span>
                    `;
                    sessionItem.appendChild(sessionHeader);

                    const wordsList = document.createElement('ul');
                    wordsList.classList.add('session-words-list');
                    (session.sessionWords || []).forEach(word => {
                        const listItem = document.createElement('li');
                        const statusClass = word.wasCorrect ? 'correct' : 'incorrect';
                        const statusSymbol = word.wasCorrect ? '✔' : '❌';
                        listItem.innerHTML = `<span class="${statusClass}">${statusSymbol} ${word.english}: ${word.chinese} (${(word.timeTakenSeconds || 0).toFixed(2)}s)</span>`;
                        wordsList.appendChild(listItem);
                    });
                    sessionItem.appendChild(wordsList);

                    inlineWrongWordsSessionsList.appendChild(sessionItem);

                    sessionHeader.addEventListener('click', (e) => {
                        if (e.target.type === 'checkbox') return;
                        e.stopPropagation();
                        wordsList.classList.toggle('show');
                        sessionHeader.querySelector('.toggle-icon').classList.toggle('expanded');
                    });
                });
            } else {
                inlineWrongWordsSessionsList.innerHTML = '<p style="text-align: center; color: #777;">暂无错题记录。</p>';
            }
            updateStartButtonState();
        };

        inlineWrongWordsSelection.addEventListener('change', (event) => {
            if (event.target.type === 'checkbox') {
                updateStartButtonState();
            }
        });


        document.getElementById('clear-wrong-words-button').addEventListener('click', () => {
             showMessage(`请输入确认码以清除所有错题记录。<br>此操作不可撤销！<br><br><input type="text" id="confirm-code-input" placeholder="输入确认码"><br><button id="confirm-clear-wrong-words" class="secondary" style="width: auto; margin-right: 10px;">确认清除</button><button id="cancel-clear-wrong-words" style="width: auto;">取消</button>`);

            document.getElementById('confirm-clear-wrong-words').onclick = async () => {
                const code = document.getElementById('confirm-code-input').value;
                if (code === '1234') {
                    messageDialog.style.display = 'none';
                    showLoader("正在清除所有记录...");
                    try {
                        const sessionsCollectionPath = `${USER_SESSIONS_COLLECTION_BASE}${userId}/practiceSessions`;
                        const q = query(collection(db, sessionsCollectionPath));
                        const querySnapshot = await getDocs(q);
                        
                        const batch = writeBatch(db);
                        querySnapshot.forEach(doc => {
                            batch.delete(doc.ref);
                        });
                        await batch.commit();

                        await loadPracticeSessionsFromFirestore();
                        showMessage('所有错题记录已清除。');
                        newWordsRadio.checked = true;
                        updatePracticeModeDisplay();
                    } catch (error) {
                        console.error("清除错题记录时出错: ", error);
                        showMessage("清除失败，请检查网络或重试。");
                    } finally {
                        hideLoader();
                    }
                } else {
                    showMessage('确认码不正确，清除操作已取消。');
                }
            };

            document.getElementById('cancel-clear-wrong-words').onclick = () => {
                messageDialog.style.display = 'none';
            };
        });

        // --- Setup Section Logic ---
        wordInput.addEventListener('input', () => {
            if(wordInput.value.trim() !== '') {
                uploadStatus.textContent = '已输入文本，将优先使用文本内容。';
                uploadConfirmButton.disabled = true;
                selectedFile = null;
                fileUpload.value = '';
                newWordsRadio.checked = true;
                updatePracticeModeDisplay();
            } else if (selectedFile) {
                 uploadStatus.textContent = `已选择: ${selectedFile.name}`;
                 uploadConfirmButton.disabled = false;
                 newWordsRadio.checked = true;
                 updatePracticeModeDisplay();
            } else {
                 uploadStatus.textContent = '未选择任何文件';
                 uploadConfirmButton.disabled = true;
            }
            updateStartButtonState();
        });

        selectFileButton.addEventListener('click', () => fileUpload.click());

        fileUpload.addEventListener('change', (event) => {
            selectedFile = event.target.files[0];
            if (!selectedFile) {
                uploadStatus.textContent = '未选择任何文件';
                uploadConfirmButton.disabled = true;
                updateStartButtonState();
                return;
            }
            uploadStatus.textContent = `已选择: ${selectedFile.name}`;
            uploadConfirmButton.disabled = false;
            wordInput.value = '';
            newWordsRadio.checked = true;
            updatePracticeModeDisplay();
            updateStartButtonState();
        });

        uploadConfirmButton.addEventListener('click', async () => {
            if (!selectedFile) return;
            try {
                showLoader('正在处理文件...');
                const base64Data = await fileToBase64(selectedFile);
                const mimeType = selectedFile.type || getMimeType(selectedFile.name);

                showLoader('正在提取文件内容...');
                const extractedText = await extractTextFromFile(base64Data, mimeType);
                wordInput.value = extractedText; // Populate textarea with extracted text

                uploadStatus.textContent = `文件内容已提取，请点击“准备开始”。`;
                selectedFile = null; // Reset file selection
                fileUpload.value = '';
                uploadConfirmButton.disabled = true;
                newWordsRadio.checked = true;
                updatePracticeModeDisplay();
                updateStartButtonState();

            } catch (error) {
                console.error("处理文件失败:", error);
                showMessage(`处理文件失败: ${error.message}`);
                uploadStatus.textContent = '处理失败，请重试。';
                words = [];
            } finally {
                hideLoader();
            }
        });

        const getMimeType = (filename) => {
            const extension = filename.split('.').pop().toLowerCase();
            const mimeTypes = {
                'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'png': 'image/png', 'gif': 'image/gif', 'heic': 'image/heic',
                'txt': 'text/plain', 'csv': 'text/csv', 'doc': 'application/msword',
                'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'xls': 'application/vnd.ms-excel',
                'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                'pdf': 'application/pdf'
            };
            return mimeTypes[extension] || 'application/octet-stream';
        };

        document.querySelectorAll('input[name="practice-mode"]').forEach(radio => {
            radio.addEventListener('change', updatePracticeModeDisplay);
        });
        
        mcSourceRadios.forEach(radio => {
            radio.addEventListener('change', updateMcSourceDisplay);
        });
        
        randomWordCountInput.addEventListener('input', updateStartButtonState);
        selectMcWordsButton.addEventListener('click', () => {
             openWordLibraryModal('select-mc');
        });

        googleTtsCheckbox.addEventListener('change', () => {
            googleTranslateTtsEnabled = googleTtsCheckbox.checked;
        });
        
        startButton.addEventListener('click', async () => {
            let tempWords = [];
            const selectedMode = document.querySelector('input[name="practice-mode"]:checked').value;
            
            // Handle typing practice mode separately
            if (selectedMode === 'typing-practice') {
                startTypingPractice();
                return;
            }

            // Logic for fetching words based on other modes
            if (selectedMode === 'wrong-words') {
                const selectedSessionIds = Array.from(inlineWrongWordsSelection.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
                if (selectedSessionIds.length === 0) { showMessage('请选择至少一个错题练习会话。'); return; }
                let wordsToPracticeMap = new Map();
                allPracticeSessions.forEach(session => {
                    if (selectedSessionIds.includes(session.id)) {
                        (session.sessionWords || []).filter(w => !w.wasCorrect).forEach(word => {
                            if (!wordsToPracticeMap.has(word.english)) {
                                wordsToPracticeMap.set(word.english, { english: word.english, chinese: word.chinese });
                            }
                        });
                    }
                });
                tempWords = Array.from(wordsToPracticeMap.values());
            } 
            else if (selectedMode === 'word-library' || (selectedMode === 'mc-quiz' && document.querySelector('input[name="mc-source"]:checked').value === 'manual')) {
                if (words.length === 0) { showMessage('请从单词库中选择至少一个单词。'); return; }
                tempWords = [...words];
            }
            else if (selectedMode === 'mc-quiz' && document.querySelector('input[name="mc-source"]:checked').value === 'random') {
                const count = parseInt(randomWordCountInput.value);
                if (isNaN(count) || count <= 0) { showMessage('请输入有效的随机单词数量。'); return; }
                if (count > allWordsFromLibrary.length) { showMessage(`单词库中只有 ${allWordsFromLibrary.length} 个单词，无法抽取 ${count} 个。`); return; }
                shuffleArray(allWordsFromLibrary);
                tempWords = allWordsFromLibrary.slice(0, count);
            }
            else { // new-words mode
                const parsedWords = parseWordInput(wordInput.value);
                if (parsedWords.length === 0) { showMessage('请输入单词！'); return; }
                try {
                    showLoader('正在翻译和验证单词...');
                    tempWords = await processWordsForQuiz(parsedWords);
                } catch (error) {
                     console.error("处理单词时发生错误:", error);
                     showMessage(`处理单词时发生错误: ${error.message}`);
                     hideLoader();
                     return;
                } finally {
                    hideLoader();
                }
            }

            // Transition to next step
            if (tempWords.length > 0) {
                words = tempWords;
                if (selectedMode === 'mc-quiz') {
                    await startMcQuiz();
                } else {
                    setupSection.style.display = 'none';
                    modeSelectionWordCount.textContent = words.length;
                    modeSelectionSection.style.display = 'block';
                }
            } else {
                showMessage('未能成功处理或选中单词，请检查输入或网络。');
            }
        });

        // Event listeners for the mode selection screen
        modeSelectFlashcard.addEventListener('click', startFlashcards);
        modeSelectPractice.addEventListener('click', startQuiz);
        modeSelectBack.addEventListener('click', () => {
            modeSelectionSection.style.display = 'none';
            setupSection.style.display = 'block';
            if (!wordLibraryRadio.checked) { words = []; }
            updateStartButtonState();
        });


        // --- Word Library Management Logic ---
        const updateSelectedLibraryDisplay = () => {
            if (wordLibraryRadio.checked) {
                selectedLibraryDisplay.innerHTML = words.length > 0 ? `已选择 <span>${words.length}</span> 个单词` : '未选择单词';
            }
            if (mcQuizRadio.checked) {
                mcSelectedDisplay.innerHTML = words.length > 0 ? `已选择 <span>${words.length}</span> 个单词` : '未选择单词';
            }
        };

        const openWordLibraryModal = async (purpose = 'manage') => {
             if (!isAuthReady) {
                showMessage("Firebase 未准备好，无法使用单词库功能。请检查网络。");
                return;
            }
            
            wordLibraryModal.dataset.purpose = purpose; // 'manage', 'select-spell', 'select-mc'

            if (purpose === 'manage') {
                modalTitle.textContent = '管理单词库';
                manageView.style.display = 'block';
                selectView.style.display = 'none';
                loadLibrariesForManageMode();
                subsetManagementSection.style.display = 'none';
                wordsManagementSection.style.display = 'none';
                subsetsList.innerHTML = '<p style="text-align: center; color: #777;">请先选择一个单词库。</p>';
                subsetWordsInput.value = '';
            } else {
                modalTitle.textContent = '选择单词进行练习';
                manageView.style.display = 'none';
                selectView.style.display = 'block';
                await buildPracticeSelectionTree();
            }
            wordLibraryModal.style.display = 'flex';
        };
        
        openManageModalButton.addEventListener('click', () => openWordLibraryModal('manage'));
        selectLibraryForPracticeButton.addEventListener('click', () => openWordLibraryModal('select-spell'));


        modalCloseButton.addEventListener('click', () => {
            wordLibraryModal.style.display = 'none';
            updateSelectedLibraryDisplay();
            updateStartButtonState();
        });

        createLibraryButton.addEventListener('click', async () => {
            const name = newLibraryNameInput.value.trim();
            if (!name) { showMessage('请输入单词库名称。'); return; }
            if (!userId) { showMessage('用户未认证，无法创建单词库。'); return; }
            showLoader('正在创建单词库...');
            try {
                const librariesRef = collection(db, PUBLIC_LIBRARIES_COLLECTION);
                await addDoc(librariesRef, { name: name, userId: userId });
                newLibraryNameInput.value = '';
                await loadLibrariesForManageMode();
                showMessage(`单词库 "${name}" 创建成功！`);
            } catch (error) {
                console.error("创建单词库失败:", error);
                showMessage("创建单词库失败，请重试。");
            } finally {
                hideLoader();
            }
        });

        const loadLibrariesForManageMode = async () => {
            if (!isAuthReady || !userId) {
                librariesList.innerHTML = '<p style="text-align: center; color: #777;">请登录后查看单词库。</p>';
                return;
            }
            showLoader('正在加载单词库...');
            try {
                const librariesRef = collection(db, PUBLIC_LIBRARIES_COLLECTION);
                const querySnapshot = await getDocs(librariesRef);
                allLibraries = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                librariesList.innerHTML = '';
                if (allLibraries.length === 0) {
                    librariesList.innerHTML = '<p style="text-align: center; color: #777;">暂无单词库。</p>';
                } else {
                    allLibraries.forEach(library => {
                        const div = document.createElement('div');
                        div.classList.add('modal-list-item', 'library-item');
                        div.dataset.id = library.id;
                        div.dataset.name = library.name;
                        
                        const ownerText = library.userId === userId ? ' (我创建的)' : '';
                        div.innerHTML = `<span>${library.name}${ownerText}</span>
                                        <div>
                                            <button data-id="${library.id}" data-name="${library.name}" class="rename-library-button secondary">重命名</button>
                                            <button data-id="${library.id}" class="delete-library-button secondary">删除</button>
                                        </div>`;
                        librariesList.appendChild(div);

                        div.addEventListener('click', async (e) => {
                            if (e.target.tagName === 'BUTTON') return;
                            librariesList.querySelectorAll('.modal-list-item').forEach(item => item.classList.remove('selected'));
                            subsetsList.innerHTML = '<p style="text-align: center; color: #777;">请先选择一个单词库。</p>';
                            subsetWordsInput.value = '';
                            selectedSubsetId = null;
                            selectedSubsetName = null;
                            wordsManagementSection.style.display = 'none';

                            div.classList.add('selected');
                            selectedLibraryId = library.id;
                            selectedLibraryName = library.name;
                            currentLibraryNameSpan.textContent = selectedLibraryName;
                            subsetManagementSection.style.display = 'flex';
                            await loadSubsetsForManageMode(selectedLibraryId);
                        });
                    });
                }
            } catch (error) {
                console.error("加载单词库失败:", error);
                showMessage("加载单词库失败，请检查网络。");
            } finally {
                hideLoader();
            }
        };

        librariesList.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('delete-library-button')) {
                const libraryIdToDelete = target.dataset.id;
                const libraryToDelete = allLibraries.find(lib => lib.id === libraryIdToDelete);

                showMessage(`请输入确认码以删除单词库 "<strong>${libraryToDelete.name}</strong>"。<br>此操作不可撤销！<br><br><input type="text" id="confirm-code-input" placeholder="输入确认码"><br><button id="confirm-delete-library" class="secondary" style="width: auto; margin-right: 10px;">确认删除</button><button id="cancel-delete-library" style="width: auto;">取消</button>`);

                document.getElementById('confirm-delete-library').onclick = async () => {
                    const code = document.getElementById('confirm-code-input').value;
                    if (code === '1234') {
                        messageDialog.style.display = 'none';
                        showLoader('正在删除单词库...');
                        try {
                            const batch = writeBatch(db);
                            const subsetsToDeleteSnapshot = await getDocs(query(collection(db, PUBLIC_SUBSETS_COLLECTION), where("libraryId", "==", libraryIdToDelete)));
                            for (const subsetDoc of subsetsToDeleteSnapshot.docs) {
                                const wordsSnapshot = await getDocs(query(collection(db, PUBLIC_WORDS_COLLECTION), where("subsetId", "==", subsetDoc.id)));
                                wordsSnapshot.forEach(wordDoc => batch.delete(wordDoc.ref));
                                batch.delete(subsetDoc.ref);
                            }
                            batch.delete(doc(db, PUBLIC_LIBRARIES_COLLECTION, libraryIdToDelete));
                            await batch.commit();

                            if (selectedLibraryId === libraryIdToDelete) {
                                selectedLibraryId = null; selectedLibraryName = null;
                                selectedSubsetId = null; selectedSubsetName = null;
                                subsetManagementSection.style.display = 'none';
                                wordsManagementSection.style.display = 'none';
                            }
                            await loadLibrariesForManageMode();
                            showMessage('单词库已删除。');
                        } catch (error) {
                            console.error("删除单词库失败:", error);
                            showMessage("删除单词库失败，请重试。");
                        } finally {
                            hideLoader();
                        }
                    } else {
                        showMessage('确认码不正确，删除操作已取消。');
                    }
                };
                document.getElementById('cancel-delete-library').onclick = () => {
                    messageDialog.style.display = 'none';
                };
            }
            if (target.classList.contains('rename-library-button')) {
                const libraryId = target.dataset.id;
                const libraryName = target.dataset.name;
                const library = allLibraries.find(lib => lib.id === libraryId);

                const promptHtml = (library.userId === userId) ?
                    `请输入 "${libraryName}" 的新名称：<br><input type="text" id="rename-input" value="${libraryName}">` :
                    `请输入确认码以重命名单词库 "<strong>${libraryName}</strong>"：<br><input type="text" id="confirm-code-input" placeholder="输入确认码"><br><input type="text" id="rename-input" value="${libraryName}" placeholder="新名称">`;

                showMessage(`${promptHtml}<br><br><button id="confirm-rename" class="secondary" style="width: auto; margin-right: 10px;">确认</button><button id="cancel-rename" style="width: auto;">取消</button>`);
                
                document.getElementById('confirm-rename').onclick = async () => {
                    const newName = document.getElementById('rename-input').value.trim();
                    const codeInput = document.getElementById('confirm-code-input');
                    if (codeInput && codeInput.value !== '1234') { showMessage('确认码不正确。'); return; }
                    if (!newName) { showMessage('请输入有效的单词库名称。'); return; }
                    
                    showLoader('正在重命名...');
                    try {
                        await setDoc(doc(db, PUBLIC_LIBRARIES_COLLECTION, libraryId), { name: newName }, { merge: true });
                        if (selectedLibraryId === libraryId) { selectedLibraryName = newName; }
                        await loadLibrariesForManageMode();
                        showMessage('单词库名称已更新。');
                    } catch (error) {
                        console.error("重命名失败:", error);
                        showMessage("重命名失败，请重试。");
                    } finally { hideLoader(); }
                };
                document.getElementById('cancel-rename').onclick = () => { messageDialog.style.display = 'none'; };
            } 
        });

        createSubsetButton.addEventListener('click', async () => {
            const name = newSubsetNameInput.value.trim();
            if (!name) { showMessage('请输入子集名称。'); return; }
            if (!selectedLibraryId) { showMessage('请先选择一个单词库。'); return; }
            if (!userId) { showMessage('用户未认证，无法创建子集。'); return; }
            showLoader('正在创建子集...');
            try {
                const subsetsRef = collection(db, PUBLIC_SUBSETS_COLLECTION);
                await addDoc(subsetsRef, { name: name, libraryId: selectedLibraryId, userId: userId });
                newSubsetNameInput.value = '';
                await loadSubsetsForManageMode(selectedLibraryId);
                showMessage(`子集 "${name}" 创建成功！`);
            } catch (error) {
                console.error("创建子集失败:", error);
                showMessage("创建子集失败，请重试。");
            } finally {
                hideLoader();
            }
        });

        const loadSubsetsForManageMode = async (libraryId) => {
            if (!isAuthReady || !userId || !libraryId) {
                subsetsList.innerHTML = '<p style="text-align: center; color: #777;">请先选择一个单词库。</p>';
                return;
            }
            showLoader('正在加载子集...');
            try {
                const subsetsRef = collection(db, PUBLIC_SUBSETS_COLLECTION);
                const q = query(subsetsRef, where("libraryId", "==", libraryId));
                const querySnapshot = await getDocs(q);
                const loadedSubsets = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                const wordsRef = collection(db, PUBLIC_WORDS_COLLECTION);
                const qWords = query(wordsRef, where("libraryId", "==", libraryId));
                const wordsSnapshot = await getDocs(qWords);
                allWordsInCurrentLibrary = wordsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                subsetsList.innerHTML = '';
                if (loadedSubsets.length === 0) {
                    subsetsList.innerHTML = '<p style="text-align: center; color: #777;">暂无子集。</p>';
                } else {
                    loadedSubsets.forEach(subset => {
                        const div = document.createElement('div');
                        div.classList.add('modal-list-item');
                        if (selectedSubsetId === subset.id) div.classList.add('selected');
                        
                        const wordCount = allWordsInCurrentLibrary.filter(word => word.subsetId === subset.id).length;
                        const ownerText = subset.userId === userId ? ' (我创建的)' : '';
                        
                        div.innerHTML = `<span>${subset.name} (${wordCount} 词)${ownerText}</span>
                                        <div>
                                            <button data-id="${subset.id}" data-name="${subset.name}" class="select-subset-button secondary">选择</button>
                                            <button data-id="${subset.id}" data-name="${subset.name}" class="rename-subset-button secondary" >重命名</button>
                                            <button data-id="${subset.id}" class="delete-subset-button secondary" >删除</button>
                                        </div>`;
                        subsetsList.appendChild(div);
                    });
                }
            } catch (error) {
                console.error("加载子集失败:", error);
                showMessage("加载子集失败，请检查网络。");
            } finally {
                hideLoader();
            }
        };


        subsetsList.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('select-subset-button')) {
                selectedSubsetId = target.dataset.id;
                selectedSubsetName = target.dataset.name;
                currentSubsetNameSpan.textContent = selectedSubsetName;
                
                wordsManagementSection.style.display = 'flex';
                showLoader('正在加载子集单词...');
                try {
                    const loadedWords = await loadWordsFromSubset(selectedSubsetId);
                    subsetWordsInput.value = loadedWords.map(w => `${w.english} = ${w.chinese}`).join('\n');
                } catch (error) {
                    console.error("加载子集单词失败:", error);
                    showMessage("加载子集单词失败。");
                } finally {
                    hideLoader();
                }
                subsetsList.querySelectorAll('.modal-list-item').forEach(item => item.classList.remove('selected'));
                target.closest('.modal-list-item').classList.add('selected');

            } else if (target.classList.contains('delete-subset-button')) {
                const subsetIdToDelete = target.dataset.id;
                const subsetToDelete = allSubsets.find(sub => sub.id === subsetIdToDelete);
                if (subsetToDelete && subsetToDelete.userId !== userId) {
                    showMessage('您无权删除此子集。');
                    return;
                }

                showMessage(`确定要删除子集 "<strong>${subsetToDelete.name}</strong>" 及其所有单词吗？<br>此操作不可撤销！<br><br><button id="confirm-delete-subset" class="secondary" style="width: auto; margin-right: 10px;">确认删除</button><button id="cancel-delete-subset" style="width: auto;">取消</button>`);
                
                document.getElementById('confirm-delete-subset').onclick = async () => {
                    messageDialog.style.display = 'none';
                    showLoader('正在删除子集...');
                    try {
                        const batch = writeBatch(db);
                        const wordsSnapshot = await getDocs(query(collection(db, PUBLIC_WORDS_COLLECTION), where("subsetId", "==", subsetIdToDelete)));
                        wordsSnapshot.forEach(doc => batch.delete(doc.ref));
                        batch.delete(doc(db, PUBLIC_SUBSETS_COLLECTION, subsetIdToDelete));
                        await batch.commit();

                        if (selectedSubsetId === subsetIdToDelete) {
                            selectedSubsetId = null; selectedSubsetName = null;
                            wordsManagementSection.style.display = 'none';
                            subsetWordsInput.value = '';
                        }
                        await loadSubsetsForManageMode(selectedLibraryId);
                        showMessage('子集已删除。');
                    } catch (error) {
                        console.error("删除子集失败:", error);
                        showMessage("删除子集失败，请重试。");
                    } finally {
                        hideLoader();
                    }
                };
                document.getElementById('cancel-delete-subset').onclick = () => { messageDialog.style.display = 'none'; };
            }
            if (target.classList.contains('rename-subset-button')) {
                // Similar rename logic as for libraries
            }
        });

        let selectedSubsetFile = null;
        subsetFileUpload.addEventListener('change', (event) => {
            selectedSubsetFile = event.target.files[0];
            if (!selectedSubsetFile) {
                subsetUploadStatus.textContent = '未选择任何文件';
                uploadSubsetConfirmButton.disabled = true;
                return;
            }
            subsetUploadStatus.textContent = `已选择: ${selectedSubsetFile.name}`;
            uploadSubsetConfirmButton.disabled = false;
        });

        selectSubsetFileButton.addEventListener('click', () => {
            subsetFileUpload.click();
        });

        uploadSubsetConfirmButton.addEventListener('click', async () => {
            if (!selectedSubsetId) { showMessage('请先选择一个子集来导入单词。'); return; }
            if (!selectedSubsetFile) { showMessage('请先选择一个文件。'); return; }

            showLoader('正在处理文件...');
            try {
                const base64Data = await fileToBase64(selectedSubsetFile);
                const mimeType = selectedSubsetFile.type || getMimeType(selectedSubsetFile.name);

                const extractedText = await extractTextFromFile(base64Data, mimeType);
                let importedWords = await processWordsForQuiz(parseWordInput(extractedText));

                const existingWords = new Set(subsetWordsInput.value.split('\n').map(line => line.split(/[-=＝－]/)[0].trim().toLowerCase()).filter(Boolean));
                const newWordsToAppend = importedWords.filter(w => !existingWords.has(w.english.toLowerCase()));

                if (newWordsToAppend.length > 0) {
                    const newContentLines = newWordsToAppend.map(w => `${w.english} = ${w.chinese || ''}`);
                    subsetWordsInput.value = subsetWordsInput.value.trim() ? `${subsetWordsInput.value.trim()}\n${newContentLines.join('\n')}` : newContentLines.join('\n');
                    subsetUploadStatus.textContent = `成功导入 ${newWordsToAppend.length} 个新单词。请点击“保存”。`;
                } else {
                    subsetUploadStatus.textContent = `导入完成，没有发现新单词。`;
                }
            } catch (error) {
                console.error("导入文件失败:", error);
                showMessage(`导入文件失败: ${error.message}`);
                subsetUploadStatus.textContent = '导入失败，请重试。';
            } finally {
                hideLoader();
                selectedSubsetFile = null;
                subsetFileUpload.value = '';
                uploadSubsetConfirmButton.disabled = true;
            }
        });


        saveSubsetWordsButton.addEventListener('click', async () => {
            if (!selectedSubsetId) { showMessage('请先选择一个子集。'); return; }
            const rawWordsInput = subsetWordsInput.value.trim();
            saveSubsetWordsButton.disabled = true;
            saveSubsetWordsButton.textContent = '正在保存...';
            
            try {
                const parsedWordsFromInput = parseWordInput(rawWordsInput);
                const processedWordsFromInput = await processWordsForQuiz(parsedWordsFromInput);
                const existingWordsInSubset = await loadWordsFromSubset(selectedSubsetId);

                const existingWordsMap = new Map(existingWordsInSubset.map(w => [w.english.toLowerCase(), w]));
                const inputWordsMap = new Map(processedWordsFromInput.map(w => [w.english.toLowerCase(), w]));

                const batch = writeBatch(db);
                let changesMade = 0;

                for (const [key, inputWord] of inputWordsMap.entries()) {
                    if (existingWordsMap.has(key)) {
                        const existingWord = existingWordsMap.get(key);
                        if (existingWord.chinese !== inputWord.chinese) {
                            batch.update(doc(db, PUBLIC_WORDS_COLLECTION, existingWord.id), { chinese: inputWord.chinese });
                            changesMade++;
                        }
                    } else {
                        batch.set(doc(collection(db, PUBLIC_WORDS_COLLECTION)), {
                            english: inputWord.english, chinese: inputWord.chinese, subsetId: selectedSubsetId,
                            libraryId: selectedLibraryId, userId: userId
                        });
                        changesMade++;
                    }
                }

                for (const [key, existingWord] of existingWordsMap.entries()) {
                    if (!inputWordsMap.has(key)) {
                        batch.delete(doc(db, PUBLIC_WORDS_COLLECTION, existingWord.id));
                        changesMade++;
                    }
                }

                if (changesMade === 0) {
                    showMessage('没有新的或需要更新的单词。');
                } else {
                    await batch.commit();
                    showMessage(`单词已保存！共 ${changesMade} 处变更。`);
                    await loadSubsetsForManageMode(selectedLibraryId);
                }
            } catch (error) {
                console.error("保存单词失败:", error);
                showMessage("保存单词失败，请重试。");
            } finally {
                hideLoader();
                saveSubsetWordsButton.disabled = false;
                saveSubsetWordsButton.textContent = '保存单词到子集';
            }
        });

        const loadWordsFromSubset = async (subsetId) => {
            if (!isAuthReady || !userId || !subsetId) return [];
            try {
                const wordsRef = collection(db, PUBLIC_WORDS_COLLECTION);
                const q = query(wordsRef, where("subsetId", "==", subsetId));
                const querySnapshot = await getDocs(q);
                return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error("从子集加载单词失败:", error);
                showMessage("从子集加载单词失败，请检查网络。");
                return [];
            }
        };
        
        // --- Word Library Practice Selection Logic ---
        const buildPracticeSelectionTree = async () => {
            librarySelectionTree.innerHTML = '<p style="text-align: center; color: #777;">正在加载单词库...</p>';
            if (!isAuthReady) return;

            try {
                const libsSnapshot = await getDocs(query(collection(db, PUBLIC_LIBRARIES_COLLECTION)));
                const allLibs = libsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                
                const subsetsSnapshot = await getDocs(query(collection(db, PUBLIC_SUBSETS_COLLECTION)));
                const allSubsets = subsetsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                
                const wordsSnapshot = await getDocs(query(collection(db, PUBLIC_WORDS_COLLECTION)));
                const allWords = wordsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));

                librarySelectionTree.innerHTML = '';
                if (allLibs.length === 0) {
                    librarySelectionTree.innerHTML = '<p style="text-align: center; color: #777;">没有可用的单词库。</p>';
                    return;
                }

                allLibs.forEach(lib => {
                    const libNode = document.createElement('div');
                    libNode.className = 'library-node';
                    libNode.innerHTML = `<div class="library-header">${lib.name}</div>`;
                    
                    const subsetsInLib = allSubsets.filter(s => s.libraryId === lib.id);
                    if (subsetsInLib.length > 0) {
                        subsetsInLib.forEach(subset => {
                            const subsetNode = document.createElement('div');
                            subsetNode.className = 'subset-node';
                            
                            const wordsInSubset = allWords.filter(w => w.subsetId === subset.id);
                            
                            const subsetHeader = document.createElement('div');
                            subsetHeader.className = 'subset-header';
                            subsetHeader.innerHTML = `
                                <span class="subset-toggle">▶</span>
                                <input type="checkbox" class="subset-checkbox" data-subset-id="${subset.id}">
                                <label>${subset.name} (${wordsInSubset.length} 词)</label>
                            `;
                            subsetNode.appendChild(subsetHeader);

                            if (wordsInSubset.length > 0) {
                                const wordsList = document.createElement('ul');
                                wordsList.className = 'words-list-container';
                                wordsList.dataset.subsetId = subset.id;
                                wordsInSubset.forEach(word => {
                                    wordsList.innerHTML += `
                                        <li class="word-item">
                                            <input type="checkbox" class="word-checkbox" data-english="${word.english}" data-chinese="${word.chinese}" data-subset-id="${subset.id}">
                                            <label>${word.english} - ${word.chinese}</label>
                                        </li>
                                    `;
                                });
                                subsetNode.appendChild(wordsList);
                            }
                            libNode.appendChild(subsetNode);
                        });
                    }
                    librarySelectionTree.appendChild(libNode);
                });

            } catch (e) {
                console.error("Error building selection tree:", e);
                librarySelectionTree.innerHTML = '<p style="text-align: center; color: #dc3545;">加载失败，请重试。</p>';
            }
        };

        librarySelectionTree.addEventListener('click', (e) => {
            const target = e.target;
            // Toggle word list visibility
            if (target.closest('.subset-header')) {
                const header = target.closest('.subset-header');
                const wordList = header.nextElementSibling;
                if (wordList && wordList.classList.contains('words-list-container')) {
                    header.querySelector('.subset-toggle').classList.toggle('expanded');
                    wordList.classList.toggle('show');
                }
            }
        });

        librarySelectionTree.addEventListener('change', (e) => {
            const target = e.target;
            // Subset checkbox changed
            if (target.classList.contains('subset-checkbox')) {
                const subsetId = target.dataset.subsetId;
                const isChecked = target.checked;
                const wordCheckboxes = librarySelectionTree.querySelectorAll(`.word-checkbox[data-subset-id="${subsetId}"]`);
                wordCheckboxes.forEach(cb => cb.checked = isChecked);
            }
            // Word checkbox changed
            if (target.classList.contains('word-checkbox')) {
                const subsetId = target.dataset.subsetId;
                const allWordCheckboxes = librarySelectionTree.querySelectorAll(`.word-checkbox[data-subset-id="${subsetId}"]`);
                const checkedWordCheckboxes = librarySelectionTree.querySelectorAll(`.word-checkbox[data-subset-id="${subsetId}"]:checked`);
                const subsetCheckbox = librarySelectionTree.querySelector(`.subset-checkbox[data-subset-id="${subsetId}"]`);
                
                if (checkedWordCheckboxes.length === allWordCheckboxes.length) {
                    subsetCheckbox.checked = true;
                    subsetCheckbox.indeterminate = false;
                } else if (checkedWordCheckboxes.length > 0) {
                    subsetCheckbox.checked = false;
                    subsetCheckbox.indeterminate = true;
                } else {
                    subsetCheckbox.checked = false;
                    subsetCheckbox.indeterminate = false;
                }
            }
            
            // Update count and button state
            const selectedWords = librarySelectionTree.querySelectorAll('.word-checkbox:checked');
            const count = selectedWords.length;
            selectedWordCountSpan.textContent = count;
            confirmLibrarySelectionButton.disabled = count === 0;
        });

        confirmLibrarySelectionButton.addEventListener('click', () => {
            const selectedWordCheckboxes = librarySelectionTree.querySelectorAll('.word-checkbox:checked');
            words = Array.from(selectedWordCheckboxes).map(cb => ({
                english: cb.dataset.english,
                chinese: cb.dataset.chinese
            }));
            
            wordLibraryModal.style.display = 'none';
            updateSelectedLibraryDisplay();
            updateStartButtonState();
        });

        // Initial update of button states and display
        updatePracticeModeDisplay();
        updateStartButtonState();
    </script>
</body>
</html>
