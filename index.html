<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½è‹±è¯­å•è¯é»˜å†™ Pro</title>
    <style>
        /* General Body Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Main Container */
        .container {
            width: 100%;
            max-width: 800px; /* Increased max-width for typing practice */
            background-color: #ffffff;
            padding: 25px 30px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden; /* Prevents box shadow from being cut off */
        }

        /* --- MODIFIED: Fix for setup section layout --- */
        #setup-section {
            /* This ensures that when display is toggled to 'flex' by the showPage() function, 
               it behaves as a column, preserving the vertical layout of its children. 
               This fixes the layout issue when returning to the main menu. */
            flex-direction: column;
        }

        /* Loading Overlay */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.85);
            z-index: 10;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border-radius: 12px;
        }
        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #007bff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        #loader p {
            margin-top: 15px;
            font-weight: bold;
            color: #007bff;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Headings */
        h1, h2, h3, h4 {
            text-align: center;
            color: #0056b3;
            margin-bottom: 20px;
        }

        p {
            line-height: 1.6;
            text-align: center;
            color: #555;
            margin-bottom: 20px;
        }

        /* Text Area for Word Input */
        textarea {
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
            box-sizing: border-box;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.15);
        }
        
        /* File Upload Styles */
        .upload-section {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        }
        #upload-status {
            color: #666;
            margin-top: 10px;
            min-height: 20px;
            font-style: italic;
        }
        .upload-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        #image-upload {
            display: none;
        }

        /* Buttons */
        button {
            display: block;
            width: 100%;
            padding: 12px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, box-shadow 0.3s ease, opacity 0.3s;
        }
        button.secondary {
            background-color: #6c757d;
        }
        button.tertiary {
            background-color: #28a745;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
        button.tertiary:hover {
            background-color: #218838;
        }
        button:disabled {
            background-color: #a0a0a0;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.7;
        }
        button:hover:not(:disabled) {
            background-color: #0056b3;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.2);
        }

        /* Quiz Section Styles */
        .quiz-section, #mc-quiz-section { display: none; }
        .quiz-header { display: flex; justify-content: space-between; align-items: center; }
        .progress { color: #666; font-size: 16px; }
        .chinese-prompt { font-size: 2.2rem; font-weight: bold; text-align: center; margin: 20px 0; padding: 25px; background-color: #e9f5ff; border-radius: 8px; color: #0056b3; word-wrap: break-word; }
        #english-input { width: 100%; padding: 15px; font-size: 22px; text-align: center; border: 2px solid #ccc; border-radius: 8px; box-sizing: border-box; margin-bottom: 15px; letter-spacing: 2px; }
        #english-input:focus { outline: none; border-color: #007bff; }
        #feedback, #mc-feedback { text-align: center; font-size: 18px; font-weight: bold; min-height: 25px; margin-bottom: 15px; transition: color 0.3s; }
        .correct { color: #28a745; }
        .incorrect { color: #dc3545; }
        .button-group { display: flex; flex-direction: column; gap: 10px; }
        .quiz-actions { display: flex; gap: 10px; }

        /* Completion Section Styles */
        .completion-section { display: none; text-align: center; }
        .completion-section h2 { color: #28a745; }
        #score-display { font-size: 22px; margin: 20px 0; }
        #wrong-words-list { text-align: left; margin-top: 20px; }
        #wrong-words-list h3 { text-align: center; color: #dc3545; }
        #wrong-words-list ul { list-style-type: none; padding: 0; }
        #wrong-words-list li { background-color: #fff8f8; border: 1px solid #f5c6cb; border-radius: 4px; padding: 10px; margin-bottom: 8px; }

        /* Checkbox style */
        .checkbox-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px; /* Adjusted margin */
            gap: 10px;
            font-size: 16px;
            color: #555;
        }

        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #007bff; /* Colors the checkbox itself */
            cursor: pointer;
        }

        /* Radio button container */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 16px;
            color: #333;
        }

        .radio-group input[type="radio"] {
            accent-color: #007bff;
            width: 18px;
            height: 18px;
        }
        
        /* Section for specific mode settings */
        .mode-setup-section {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
        }
        .mode-setup-section h3 {
            text-align: center;
            color: #0056b3;
            margin-top: 0;
            margin-bottom: 10px;
        }

        /* Inline Wrong Words Selection Styles */
        #inline-wrong-words-sessions-list {
            max-height: 300px; /* Scrollable area for sessions */
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
            flex-grow: 1; /* Allow it to grow */
        }

        .session-item {
            display: flex;
            flex-direction: column;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .session-item:last-child {
            border-bottom: none;
        }

        .session-item:hover {
            background-color: #f5f5f5;
        }

        .session-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .session-header input[type="checkbox"] {
            margin-right: 10px;
            accent-color: #007bff;
        }

        .session-header .session-info {
            flex-grow: 1;
            font-size: 14px; /* Slightly smaller font for more info */
        }
        .session-info .session-mode {
             display: block;
             font-size: 0.9em;
             color: #666;
        }

        .session-header .toggle-icon {
            font-size: 1.2em;
            margin-left: 10px;
            transition: transform 0.2s ease;
        }

        .session-header .toggle-icon.expanded {
            transform: rotate(90deg);
        }

        .session-words-list {
            list-style-type: none;
            padding-left: 30px; /* Indent the list */
            margin-top: 10px;
            margin-bottom: 0;
            font-size: 0.9em;
            color: #666;
            display: none; /* Hidden by default */
        }

        .session-words-list.show {
            display: block;
        }

        .session-words-list li {
            margin-bottom: 5px;
        }
        .session-words-list .correct { color: #28a745; }
        .session-words-list .incorrect { color: #dc3545; }

        .inline-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end; /* Align buttons to the right */
            margin-top: 15px;
        }

        .inline-buttons button {
            width: auto; /* Allow buttons to size based on content */
            padding: 10px 20px;
            font-size: 16px;
        }

        /* General Message Dialog */
        #message-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            padding: 25px;
            z-index: 1001; /* Higher than example sentence display */
            max-width: 400px;
            text-align: center;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 20px;
        }
        #message-dialog-text {
            font-size: 1.1em;
            color: #333;
            line-height: 1.6;
            text-align: left; /* MODIFIED: Better for lists */
        }
        #message-dialog-close-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            align-self: center;
        }
        #message-dialog-close-button:hover {
            background-color: #0056b3;
        }

        /* Example Sentence Container */
        #example-sentence-container {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 8px;
            text-align: center;
        }
        #example-sentence-container p {
            margin: 0;
            line-height: 1.5;
        }
        #english-example-sentence {
            font-weight: bold;
            color: #0056b3;
            margin-bottom: 5px;
        }
        #chinese-example-sentence {
            color: #666;
        }

        /* Word Library Specific Styles */
        .word-library-selection-display {
            text-align: center;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            min-height: 20px; /* Ensure space even if nothing selected */
        }
        .word-library-selection-display span {
            color: #007bff;
        }

        /* Modal for Word Library Management */
        #word-library-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        .modal-header h2 {
            margin: 0;
            color: #0056b3;
        }
        .modal-close-button {
            background: none;
            border: none;
            font-size: 24px;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: auto; /* Override general button width */
            transition: color 0.2s;
        }
        .modal-close-button:hover {
            color: #333;
        }

        .modal-section {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .modal-section h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #0056b3;
        }
        .modal-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 5px;
            background-color: #fff;
        }
        .modal-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .modal-list-item:last-child {
            border-bottom: none;
        }
        .modal-list-item:hover {
            background-color: #f5f5f5;
        }
        .modal-list-item.selected {
            background-color: #e6f2ff;
            border-color: #007bff;
            font-weight: bold;
        }
        .modal-list-item.disabled {
            background-color: #f8f8f8;
            color: #aaa;
            cursor: not-allowed;
        }
        .modal-list-item button {
            width: auto;
            padding: 5px 10px;
            font-size: 14px;
            margin-left: 10px;
        }
        .modal-input-group {
            display: flex;
            gap: 10px;
        }
        .modal-input-group input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
        }
        .modal-input-group button {
            width: auto;
            padding: 8px 15px;
            font-size: 16px;
        }

        /* Modal specific mode styles */
        #word-library-modal[data-mode="select"] .manage-only { display: none; }
        #word-library-modal[data-mode="manage"] .select-only { display: none; }

        /* Styles for Practice Selection Tree */
        #library-selection-tree { max-height: 40vh; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; padding: 10px; background-color: #fff; }
        .library-node > .library-header { font-size: 1.1em; font-weight: bold; padding: 10px; background-color: #f0f2f5; border-radius: 4px; margin-bottom: 5px; }
        .subset-node { margin-left: 20px; }
        .subset-header { display: flex; align-items: center; padding: 8px; cursor: pointer; border-radius: 4px; transition: background-color 0.2s; }
        .subset-header:hover { background-color: #f5f5f5; }
        .subset-header input[type="checkbox"] { margin-right: 10px; }
        .subset-toggle { margin-right: 8px; transition: transform 0.2s; display: inline-block; }
        .subset-toggle.expanded { transform: rotate(90deg); }
        .words-list-container { list-style-type: none; padding-left: 40px; display: none; }
        .words-list-container.show { display: block; }
        .word-item { display: flex; align-items: center; padding: 5px 0; }
        .word-item input[type="checkbox"] { margin-right: 10px; }
        .word-item label { color: #555; }

        /* Flashcard Styles */
        #flashcard-section {
            display: none;
            flex-direction: column;
            gap: 15px;
        }
        .flashcard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .flashcard-progress {
            font-size: 16px;
            color: #666;
        }
        .flashcard {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            text-align: center;
            position: relative;
            min-height: 350px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .flashcard-word {
            font-size: 3rem;
            font-weight: bold;
            color: #0056b3;
            margin-bottom: 10px;
        }
        .flashcard-pos {
            font-style: italic;
            color: #666;
            margin-bottom: 20px;
        }
        .flashcard-chinese {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 25px;
        }
        .flashcard-example {
            font-size: 1rem;
            line-height: 1.5;
            color: #555;
            width: 100%;
        }
        .flashcard-example .eng {
            font-weight: bold;
        }
        .flashcard-nav {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-top: 20px;
        }
        .flashcard-nav button, #flashcard-speak-button {
            width: 100%;
        }
        #flashcard-speak-button {
            margin-top: 15px;
        }
        #flashcard-completion-options {
            display: none;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        .flashcard .spinner-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
        }

        /* Mode Selection Styles */
        #mode-selection-section {
            display: none;
            text-align: center;
        }
        #mode-selection-section h2 {
            margin-bottom: 25px;
        }
        #mode-selection-section .button-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* --- Multiple Choice Styles --- */
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .input-group label {
            white-space: nowrap;
        }
        .input-group input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }
        #mc-quiz-prompt {
            text-align: center;
            margin: 20px 0;
        }
        #mc-quiz-prompt button {
            width: auto;
            padding: 20px 30px;
            font-size: 24px;
            background-color: #e9f5ff;
            color: #0056b3;
            border: 2px solid #007bff;
        }
        #mc-quiz-prompt button:hover {
            background-color: #d1e7ff;
        }
        #mc-options-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        .mc-option-button {
            padding: 18px;
            font-size: 18px;
            font-weight: bold; /* Make English bold */
            background-color: #fff;
            color: #333;
            border: 1px solid #ccc;
            text-align: center;
            line-height: 1.4; /* Adjust line height for two lines */
        }
        .mc-option-button:hover:not(:disabled) {
            background-color: #f8f9fa;
            border-color: #007bff;
        }
        .mc-option-button.correct-answer {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        .mc-option-button.wrong-answer {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            opacity: 0.7;
        }
        
        /* --- Typing Practice Styles --- */
        #typing-practice-section {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
        }
        #typing-practice-section h2 {
            margin-top: 150px; /* Increased margin to prevent keyboard from overlapping leaderboard */
        }
        #keyboard-container {
            position: relative;
            width: 100%;
            max-width: 750px;
            margin-top: 0; /* REMOVED margin */
        }
        #keyboard-img {
            width: 100%;
            height: auto;
            border-radius: 8px;
        }
        #next-char-indicator {
            position: absolute;
            font-size: 48px;
            font-weight: bold;
            color: #dc3545;
            background-color: rgba(255, 255, 0, 0.7);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-transform: uppercase;
            pointer-events: none;
            transition: top 0.1s, left 0.1s;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);
            display: none; /* Hidden initially */
        }
        #typing-info {
            text-align: center;
            font-size: 22px;
            font-weight: bold;
            color: #0056b3;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        #typing-info .new-record {
            color: #e67e22;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        /* MODIFICATION START: Styles for the new leaderboard */
        #leaderboard {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 450px;
            z-index: 5;
        }
        #leaderboard h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #0056b3;
            text-align: center;
        }
        #leaderboard-lists-container {
            display: flex;
            justify-content: space-around;
            gap: 20px;
        }
        #leaderboard-lists-container ol {
            margin: 0;
            padding-left: 20px;
            font-size: 14px;
            flex: 1;
        }
        #leaderboard-lists-container li {
            margin-bottom: 5px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* MODIFICATION END */
        #typing-back-button {
            width: auto;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
        }

        /* --- MODIFIED: User Profile Section --- */
        #profile-section {
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px; /* Spacing from radio group */
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #profile-display {
            text-align: center;
            font-size: 16px;
            color: #333;
        }
        #current-profile-name {
            color: #007bff;
            font-weight: bold;
        }
        #profile-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
        #profile-controls select, #profile-controls input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        #profile-controls input {
            flex-grow: 1;
            max-width: 200px;
        }
        #profile-controls button {
            width: auto;
            padding: 8px 15px;
            font-size: 14px;
            font-weight: normal; /* Override bold */
        }

        /* --- NEW: Persistent User Display --- */
        #persistent-profile-display {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 14px;
            color: #333;
            background-color: rgba(240, 242, 245, 0.9); /* Semi-transparent background */
            padding: 5px 12px;
            border-radius: 6px;
            z-index: 5;
            pointer-events: none; /* So it doesn't block buttons underneath */
        }

        /* --- NEW: Advanced Typing Styles --- */
        #advanced-typing-section {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #advanced-typing-prompt {
            font-size: 2.5rem;
            font-weight: bold;
            letter-spacing: 0.5em;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            min-height: 50px;
            text-align: center;
            word-break: break-all;
            user-select: none;
        }
        #advanced-typing-prompt span {
            transition: color 0.3s ease-out;
        }
        #advanced-typing-prompt .correctly-typed {
            color: #adb5bd;
        }
        #advanced-typing-prompt .current-char {
            text-decoration: underline;
            text-decoration-color: #007bff;
            text-decoration-thickness: 3px;
        }
        #advanced-typing-feedback {
            font-size: 1.2rem;
            min-height: 30px;
            font-weight: bold;
        }
        #advanced-typing-feedback .combo {
            color: #fd7e14;
            animation: pulse 0.5s;
        }
        #advanced-typing-back-button {
            width: auto;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
        }

    </style>
</head>
<body>

    <div class="container">
        <div id="loader">
            <div class="spinner"></div>
            <p id="loader-text">æ­£åœ¨å¤„ç†...</p>
        </div>

        <!-- NEW: Persistent Profile Display (for non-setup pages) -->
        <div id="persistent-profile-display" style="display: none;"></div>

        <div id="setup-section">
            <h1>æ™ºèƒ½è‹±è¯­å•è¯é»˜å†™</h1>
            <p>é€‰æ‹©ä¸€ç§ç»ƒä¹ æ¨¡å¼å¼€å§‹ã€‚</p>
            
            <!-- MODIFIED: Profile Section is now here -->
            <div id="profile-section">
                <div id="profile-display">
                    å½“å‰ç»ƒä¹ ç”¨æˆ·: <span id="current-profile-name">æœªé€‰æ‹©</span>
                </div>
                <div id="profile-controls">
                    <select id="profile-select">
                        <option value="">-- é€‰æ‹©å·²æœ‰ç”¨æˆ· --</option>
                    </select>
                    <input type="text" id="new-profile-name-input" placeholder="æˆ–åˆ›å»ºæ–°ç”¨æˆ·">
                    <button id="set-profile-button">è®¾ç½®ç”¨æˆ·</button>
                </div>
            </div>

            <div class="radio-group">
                <label>
                    <input type="radio" name="practice-mode" value="new-words" id="new-words-radio" checked>
                    å•è¯æ‹¼å†™ç»ƒä¹ 
                </label>
                <label>
                    <input type="radio" name="practice-mode" value="mc-quiz" id="mc-quiz-radio">
                    å•è¯é€‰æ‹©é¢˜
                </label>
                <!-- MODIFICATION START: Added advanced typing practice -->
                <label>
                    <input type="radio" name="practice-mode" value="typing-practice" id="typing-practice-radio">
                    A-Z æ‰“å­—ç»ƒä¹ 
                </label>
                 <label>
                    <input type="radio" name="practice-mode" value="advanced-typing" id="advanced-typing-radio">
                    è¿›é˜¶æ‰“å­—ç»ƒä¹ 
                </label>
                <!-- MODIFICATION END -->
                <label>
                    <input type="radio" name="practice-mode" value="wrong-words" id="wrong-words-radio" disabled>
                    é”™é¢˜ç»ƒä¹  (<span id="wrong-words-count">0</span> ä¸ªå•è¯)
                </label>
                <label>
                    <input type="radio" name="practice-mode" value="word-library" id="word-library-radio">
                    å•è¯åº“æ‹¼å†™
                </label>
            </div>

            <div id="new-words-input-area" class="mode-setup-section" style="display: flex;">
                <h3>æ–°å•è¯æ‹¼å†™</h3>
                <textarea id="word-input" placeholder="æ–¹æ³•ä¸€ï¼šåœ¨æ­¤å¤„è¾“å…¥å•è¯..."></textarea>
                <div class="upload-section">
                    <p style="margin-bottom: 10px;">æ–¹æ³•äºŒï¼šä¸Šä¼ å•è¯æ–‡ä»¶ (å›¾ç‰‡, TXT, PDF, Word, HEICç­‰)</p>
                    <div class="upload-buttons">
                        <button id="select-file-button" class="secondary">é€‰æ‹©æ–‡ä»¶</button>
                        <button id="upload-confirm-button" disabled>ä¸Šä¼ å¹¶è¯†åˆ«</button>
                    </div>
                    <div id="upload-status">æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶</div>
                </div>
                <input type="file" id="file-upload" accept="image/*,.txt,.csv,.doc,.docx,.xls,.xlsx,.pdf,.heic" style="display: none;">
            </div>
            
            <div id="multiple-choice-setup-area" class="mode-setup-section">
                <h3>å•è¯é€‰æ‹©é¢˜è®¾ç½®</h3>
                <div class="radio-group" style="background-color: transparent; border: none; padding: 0;">
                    <label><input type="radio" name="mc-source" value="random" checked> ä»å•è¯åº“éšæœºæŠ½å–</label>
                    <div id="mc-random-options" class="input-group" style="padding-left: 25px;">
                        <label for="random-word-count-input">æ•°é‡:</label>
                        <input type="number" id="random-word-count-input" value="10" step="5" min="5">
                        <span>(ä»æ€»åº“ <span id="total-word-count">0</span> ä¸ªè¯ä¸­)</span>
                    </div>
                    <label><input type="radio" name="mc-source" value="manual"> ä»å•è¯åº“æ‰‹åŠ¨é€‰æ‹©</label>
                    <div id="mc-manual-options" style="display: none; padding-left: 25px;">
                        <div id="mc-selected-display" class="word-library-selection-display">æœªé€‰æ‹©å•è¯</div>
                        <button id="select-mc-words-button" class="secondary" style="font-size: 16px; padding: 10px;">æ‰“å¼€å•è¯åº“é€‰æ‹©</button>
                    </div>
                </div>
            </div>

            <div id="inline-wrong-words-selection" class="mode-setup-section">
                <h3>é€‰æ‹©é”™é¢˜ç»ƒä¹ ä¼šè¯</h3>
                <div id="inline-wrong-words-sessions-list" class="modal-sessions-list"></div>
                <div class="inline-buttons">
                    <button id="clear-wrong-words-button" class="secondary">æ¸…é™¤æ‰€æœ‰é”™é¢˜è®°å½•</button>
                </div>
            </div>

            <div id="word-library-selection-area" class="mode-setup-section">
                <h3>å•è¯åº“æ‹¼å†™</h3> 
                <div id="selected-library-display" class="word-library-selection-display">æœªé€‰æ‹©å•è¯</div>
                <div style="display: flex; gap: 10px; flex-direction: column;">
                    <button id="select-library-for-practice-button">é€‰æ‹©å•è¯è¿›è¡Œç»ƒä¹ </button>
                    <button id="open-manage-modal-button" class="secondary">ç®¡ç†å•è¯åº“ (åˆ›å»º/åˆ é™¤/ç¼–è¾‘)</button>
                </div>
            </div>
            
            <!-- This section is for modes that don't need specific setup, like typing -->
            <div id="simple-mode-area" class="mode-setup-section">
                 <h3>A-Z æ‰“å­—ç»ƒä¹ </h3>
                 <p>å‡†å¤‡å¥½åï¼Œç‚¹å‡»â€œå‡†å¤‡å¼€å§‹â€å³å¯è¿›å…¥æ‰“å­—ç»ƒä¹ ç•Œé¢ã€‚</p>
            </div>
            
            <!-- MODIFICATION START: Setup area for advanced typing -->
             <div id="advanced-typing-setup-area" class="mode-setup-section">
                 <h3>è¿›é˜¶æ‰“å­—ç»ƒä¹ </h3>
                 <p>å‡†å¤‡å¥½åï¼Œç‚¹å‡»â€œå‡†å¤‡å¼€å§‹â€å³å¯è¿›å…¥æ— é™å­—æ¯æµæ‰“å­—ç»ƒä¹ ã€‚</p>
            </div>
            <!-- MODIFICATION END -->


            <div id="common-settings" style="margin-top:20px;">
                <div class="checkbox-container">
                    <input type="checkbox" id="auto-speak-checkbox" checked>
                    <label for="auto-speak-checkbox">è‡ªåŠ¨è¯»å‡ºå•è¯</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="google-tts-checkbox">
                    <label for="google-tts-checkbox">ä½¿ç”¨æ›´è‡ªç„¶çš„ Google ç¿»è¯‘è¯­éŸ³ (å®éªŒæ€§)</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-example-sentence-checkbox">
                    <label for="show-example-sentence-checkbox">æ˜¾ç¤ºå•è¯ä¾‹å¥</label>
                </div>
            </div>

            <button id="start-button" disabled>å‡†å¤‡å¼€å§‹</button>
        </div>

        <div id="mode-selection-section">
            <h2>å‡†å¤‡å°±ç»ªï¼</h2>
            <p>å·²æˆåŠŸåŠ è½½ <strong id="mode-selection-word-count">0</strong> ä¸ªå•è¯ã€‚</p>
            <div class="button-group">
                <button id="mode-select-flashcard" class="tertiary">å•è¯å¡å¤ä¹ </button>
                <button id="mode-select-typing-with-words">çœ‹è¯æ‰“å­—ç»ƒä¹ </button>
                <button id="mode-select-practice">ç›´æ¥å¼€å§‹ç»ƒä¹ </button>
                <button id="mode-select-back" class="secondary">è¿”å›</button>
            </div>
            <!-- NEW: Repetition setup for typing with words -->
            <div id="typing-repetition-setup" style="display: none; margin-top: 20px;">
                <h3>è®¾ç½®â€œçœ‹è¯æ‰“å­—â€é‡å¤æ¬¡æ•°</h3>
                <div class="radio-group" style="background-color: transparent; border: none; padding: 0; align-items: center;">
                     <div style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-bottom: 15px;">
                        <label><input type="radio" name="repetition-count" value="1" checked> 1æ¬¡</label>
                        <label><input type="radio" name="repetition-count" value="3"> 3æ¬¡</label>
                        <label><input type="radio" name="repetition-count" value="5"> 5æ¬¡</label>
                        <label><input type="radio" name="repetition-count" value="custom"> è‡ªå®šä¹‰:</label>
                        <input type="number" id="custom-repetition-input" style="width: 70px; padding: 5px;" min="1" value="1">
                    </div>
                </div>
                <div class="button-group">
                     <button id="start-typing-with-words-practice">å¼€å§‹ç»ƒä¹ </button>
                     <button id="cancel-typing-with-words-setup" class="secondary">è¿”å›</button>
                </div>
            </div>
        </div>

        <div id="flashcard-section">
            <div class="flashcard-header">
                <div id="flashcard-progress" class="flashcard-progress"></div>
                <button id="flashcard-back-to-menu-button" class="secondary" style="width: auto; padding: 8px 12px; font-size: 14px;">è¿”å›ä¸»é¡µ</button>
            </div>
            <div class="flashcard">
                <div class="spinner-container" style="display: none;"><div class="spinner"></div></div>
                <div id="flashcard-content">
                    <div id="flashcard-word" class="flashcard-word"></div>
                    <div id="flashcard-pos" class="flashcard-pos"></div>
                    <div id="flashcard-chinese" class="flashcard-chinese"></div>
                    <div id="flashcard-example" class="flashcard-example">
                        <p class="eng"></p>
                        <p class="chn"></p>
                    </div>
                </div>
            </div>
            <button id="flashcard-speak-button" class="secondary">è¯»å‡ºå•è¯</button>
            <div id="flashcard-nav" class="flashcard-nav">
                <button id="flashcard-prev-button">ä¸Šä¸€ä¸ª</button>
                <button id="flashcard-next-button">ä¸‹ä¸€ä¸ª</button>
            </div>
            <div id="flashcard-completion-options">
                <h3>å¤ä¹ å®Œæ¯•ï¼</h3>
                <button id="flashcard-finish-practice-button">å¼€å§‹ç»ƒä¹ </button>
                <button id="flashcard-finish-menu-button" class="secondary">è¿”å›ä¸»èœå•</button>
            </div>
        </div>
        
        <div id="mc-quiz-section">
            <div class="quiz-header">
                <div id="mc-progress" class="progress"></div>
                <button id="mc-back-to-menu-button" class="secondary" style="width: auto; padding: 8px 12px; font-size: 14px;">è¿”å›ä¸»é¡µ</button>
            </div>
            <div id="mc-quiz-prompt">
                <button id="mc-speak-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-volume-up-fill" viewBox="0 0 16 16">
                      <path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/>
                      <path d="M10.121 12.596A6.48 6.48 0 0 0 12.025 8a6.48 6.48 0 0 0-1.904-4.596l-.707.707A5.482 5.482 0 0 1 11.025 8a5.482 5.482 0 0 1-1.61 3.89l.706.706z"/>
                      <path d="M8.707 11.182A4.486 4.486 0 0 0 10.025 8a4.486 4.486 0 0 0-1.318-3.182L8 5.525A3.489 3.489 0 0 1 9.025 8 3.49 3.49 0 0 1 8 10.475l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06z"/>
                    </svg>
                </button>
            </div>
            <div id="mc-options-container"></div>
            <div id="mc-feedback"></div>
            <div class="button-group" style="margin-top: 20px;">
                <button id="mc-next-button" style="display: none;">ä¸‹ä¸€é¢˜</button>
            </div>
        </div>

        <div id="quiz-section" class="quiz-section">
            <div class="quiz-header">
                <div id="progress" class="progress"></div>
                <button id="back-to-menu-button" class="secondary" style="width: auto; padding: 8px 12px; font-size: 14px;">è¿”å›ä¸»é¡µ</button>
            </div>
            <div id="chinese-prompt" class="chinese-prompt"></div>
            <input type="text" id="english-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
            <div id="feedback"></div>

            <div id="example-sentence-container" style="display: none;">
                <p style="font-style: italic; color: #555;">ä¾‹å¥:</p>
                <p id="english-example-sentence"></p>
                <p id="chinese-example-sentence"></p>
            </div>

            <div class="button-group">
                 <div class="quiz-actions">
                    <button id="check-button">æ£€æŸ¥ç­”æ¡ˆ</button>
                    <button id="next-button" style="display: none;">ä¸‹ä¸€é¢˜</button>
                </div>
                <button id="speak-again-button" class="secondary">å†è¯»ä¸€æ¬¡</button> 
            </div>
        </div>

        <div id="completion-section" class="completion-section">
            <h2>ç»ƒä¹ ç»“æŸï¼</h2>
            <div id="score-display"></div>
            <div id="wrong-words-list"></div>
            <button id="restart-button">è¿”å›ä¸»é¡µ</button>
        </div>
        
        <div id="typing-practice-section">
            <div id="leaderboard">
                <h4>ğŸ† è‹±é›„æ¦œ ğŸ†</h4>
                <div id="leaderboard-lists-container"></div>
            </div>
            <h2>A-Z æ‰“å­—ç»ƒä¹ </h2>
            <div id="keyboard-container">
                <img id="keyboard-img" src="https://github.com/ashinxtc/vocabulary-tool/blob/main/KB_United_States.svg.png?raw=true" alt="US Keyboard Layout">
                <div id="next-char-indicator">A</div>
            </div>
            <div id="typing-info">
                <p>è¯·æŒ‰ 'a' é”®å¼€å§‹æ–°ä¸€è½®ç»ƒä¹ </p>
            </div>
            <button id="typing-back-button" class="secondary">è¿”å›ä¸»èœå•</button>
        </div>

        <!-- MODIFICATION START: New section for advanced typing -->
        <div id="advanced-typing-section">
            <h2>è¿›é˜¶æ‰“å­—ç»ƒä¹ </h2>
            <p id="advanced-typing-prompt"></p>
            <p id="advanced-typing-feedback"></p>
            <button id="advanced-typing-back-button" class="secondary">ç»“æŸç»ƒä¹ </button>
        </div>
        <!-- MODIFICATION END -->
    </div>

    <div id="message-dialog">
        <p id="message-dialog-text"></p>
        <button id="message-dialog-close-button">ç¡®å®š</button>
    </div>

    <div id="word-library-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">ç®¡ç†å•è¯åº“</h2>
                <button class="modal-close-button" id="modal-close-button">&times;</button>
            </div>

            <div id="manage-view">
                <div class="modal-section">
                    <h4>æˆ‘çš„å•è¯åº“</h4>
                    <div class="modal-input-group">
                        <input type="text" id="new-library-name-input" placeholder="æ–°å•è¯åº“åç§°">
                        <button id="create-library-button">åˆ›å»º</button>
                    </div>
                    <div id="libraries-list" class="modal-list"></div>
                </div>

                <div class="modal-section" id="subset-management-section" style="display: none;">
                    <h4><span id="current-library-name"></span> çš„å­é›†</h4>
                    <div class="modal-input-group">
                        <input type="text" id="new-subset-name-input" placeholder="æ–°å­é›†åç§°">
                        <button id="create-subset-button">åˆ›å»º</button>
                    </div>
                    <div id="subsets-list" class="modal-list"></div>
                </div>

                <div class="modal-section" id="words-management-section" style="display: none;">
                    <h4>å‘ <span id="current-subset-name"></span> æ·»åŠ å•è¯</h4>
                    <textarea id="subset-words-input" placeholder="æ¯è¡Œä¸€ä¸ªå•è¯ï¼Œæ ¼å¼ï¼šè‹±æ–‡#ä¸­æ–‡"></textarea>
                    
                    <div class="upload-section" style="border: 1px dashed #ccc; padding: 10px; margin-top: 10px;">
                        <p style="margin-bottom: 10px; font-size: 14px;">æˆ–ä»æ–‡ä»¶å¯¼å…¥å•è¯</p>
                        <div class="upload-buttons" style="flex-direction: column;">
                            <button id="select-subset-file-button" class="secondary" style="width: 100%; margin-bottom: 5px;">é€‰æ‹©æ–‡ä»¶</button>
                            <button id="upload-subset-confirm-button" disabled style="width: 100%;">ä¸Šä¼ å¹¶è¯†åˆ«/å¯¼å…¥</button>
                        </div>
                        <div id="subset-upload-status" style="color: #666; margin-top: 5px; min-height: 20px; font-style: italic; font-size: 14px;">æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶</div>
                    </div>
                    <input type="file" id="subset-file-upload" accept="image/*,.txt,.csv,.doc,.docx,.xls,.xlsx,.pdf,.heic" style="display: none;">
                    
                    <button id="save-subset-words-button">ä¿å­˜å•è¯åˆ°å­é›†</button>
                </div>
            </div>

            <div id="select-view" style="display: none;">
                 <div class="modal-section">
                    <h4>é€‰æ‹©è¦ç»ƒä¹ çš„å•è¯ (<span id="selected-word-count">0</span>)</h4>
                    <div id="library-selection-tree">
                        <p style="text-align: center; color: #777;">æ­£åœ¨åŠ è½½å•è¯åº“...</p>
                    </div>
                </div>
                <button id="confirm-library-selection-button" disabled>ç¡®è®¤é€‰æ‹©å¹¶è¿”å›</button>
            </div>

        </div>
    </div>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, where, getDocs, addDoc, setDoc, doc, onSnapshot, deleteDoc, writeBatch, serverTimestamp, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables
        let app;
        let db;
        let auth;
        let userId = 'anonymous'; // Default to anonymous
        let isAuthReady = false;

        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyAOPiAwJCh61dH-rMBWfOM1nKZjiID6G-s",
            authDomain: "vocabulary-29bb0.firebaseapp.com",
            projectId: "vocabulary-29bb0",
            storageBucket: "vocabulary-29bb0.firebasestorage.app",
            messagingSenderId: "480495077641",
            appId: "1:480495077641:web:6cd7b1bea6a2a70f342bd8",
            measurementId: "G-VJ6E7C5S6V"
        };
        const appId = 'vocabulary-29bb0';
        const initialAuthToken = null;

        // Firestore Collection Paths
        const PUBLIC_LIBRARIES_COLLECTION = `artifacts/${appId}/public/data/wordLibraries`;
        const PUBLIC_SUBSETS_COLLECTION = `artifacts/${appId}/public/data/wordSubsets`;
        const PUBLIC_WORDS_COLLECTION = `artifacts/${appId}/public/data/libraryWords`;
        const USER_SESSIONS_COLLECTION_BASE = `artifacts/${appId}/users/`; 
        const TYPING_SCORES_DOC = `artifacts/${appId}/public/data/typingScores/top10`;
        const USER_PROFILES_COLLECTION_BASE = `artifacts/${appId}/users/`;


        // Global variables
        let allLibraries = [], allSubsets = [], allWordsFromLibrary = [];
        let selectedLibraryId = null, selectedLibraryName = null, selectedSubsetId = null, selectedSubsetName = null;
        let allWordsInCurrentLibrary = []; 
        let words = [], originalWords = [], wrongWordsCurrentSession = [], persistentWrongWords = []; 
        let currentWordIndex = 0, score = 0;
        let selectedFile = null;
        let autoSpeakEnabled = true, googleTranslateTtsEnabled = false, showExampleSentenceEnabled = false; 
        let audioCache = new Map();
        const audioPlayer = new Audio();
        let isAudioContextUnlocked = false;
        let audioContext;
        let wordStartTime = 0, quizStartTime = null;
        let allPracticeSessions = [], currentQuizDetails = {};
        let currentFlashcardIndex = 0, currentMcQuizIndex = 0;
        let currentUserProfile = null, allUserProfiles = [];
        const alphabet = 'abcdefghijklmnopqrstuvwxyz';
        let currentTargetCharIndex = 0, typingStartTime = 0;
        let isTypingPracticeActive = false, waitingForRestart = true;
        let bestTypingScores = [];
        let isTypingWithWordsMode = false;
        let exampleSentenceCache = new Map(); 
        let typingSessionStats = {};

        // MODIFICATION START: Variables for advanced typing
        let isAdvancedTypingActive = false;
        let advancedTypingChars = [];
        let advancedTypingCurrentIndex = 0;
        let advancedTypingCombo = 0;
        let advancedTypingMaxCombo = 0;
        let advancedTypingLastCorrectTime = 0;
        let advancedTypingTotalTyped = 0;
        let advancedTypingTotalErrors = 0;
        const COMBO_THRESHOLD_MS = 1000;
        // MODIFICATION END
        
        const keyCoordinates = {
            'q': { top: 18.0, left: 9.5 }, 'w': { top: 18.0, left: 16.5 }, 'e': { top: 18.0, left: 22.5 }, 'r': { top: 18.0, left: 29.0 }, 't': { top: 18.0, left: 36.0 }, 'y': { top: 18.0, left: 42.5 }, 'u': { top: 18.0, left: 49.5 }, 'i': { top: 18.0, left: 56.5 }, 'o': { top: 18.0, left: 62.5 }, 'p': { top: 18.0, left: 69.5 },
            'a': { top: 37.0, left: 11.0 }, 's': { top: 37.0, left: 17.5 }, 'd': { top: 37.0, left: 24.0 }, 'f': { top: 37.0, left: 31.0 }, 'g': { top: 37.0, left: 37.0 }, 'h': { top: 37.0, left: 44.0 }, 'j': { top: 37.0, left: 51.0 }, 'k': { top: 37.0, left: 57.5 }, 'l': { top: 37.0, left: 64.0 },
            'z': { top: 57.0, left: 14.5 }, 'x': { top: 57.0, left: 21.0 }, 'c': { top: 57.0, left: 27.5 }, 'v': { top: 57.0, left: 34.5 }, 'b': { top: 57.0, left: 41.0 }, 'n': { top: 57.0, left: 48.0 }, 'm': { top: 57.0,  left: 54.5 }
        };

        // Get all necessary HTML elements
        const setupSection = document.getElementById('setup-section');
        const quizSection = document.getElementById('quiz-section');
        const completionSection = document.getElementById('completion-section');
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        const modeSelectionSection = document.getElementById('mode-selection-section');
        const flashcardSection = document.getElementById('flashcard-section');
        const mcQuizSection = document.getElementById('mc-quiz-section');
        const typingPracticeSection = document.getElementById('typing-practice-section');
        
        const modeSelectionWordCount = document.getElementById('mode-selection-word-count');
        const modeSelectFlashcard = document.getElementById('mode-select-flashcard');
        const modeSelectPractice = document.getElementById('mode-select-practice');
        const modeSelectBack = document.getElementById('mode-select-back');
        const flashcardProgress = document.getElementById('flashcard-progress');
        const flashcardBackToMenuButton = document.getElementById('flashcard-back-to-menu-button');
        const flashcardSpinner = document.querySelector('.flashcard .spinner-container');
        const flashcardContent = document.getElementById('flashcard-content');
        const flashcardWord = document.getElementById('flashcard-word');
        const flashcardPos = document.getElementById('flashcard-pos');
        const flashcardChinese = document.getElementById('flashcard-chinese');
        const flashcardExampleEng = document.querySelector('#flashcard-example .eng');
        const flashcardExampleChn = document.querySelector('#flashcard-example .chn');
        const flashcardSpeakButton = document.getElementById('flashcard-speak-button');
        const flashcardNav = document.getElementById('flashcard-nav');
        const flashcardPrevButton = document.getElementById('flashcard-prev-button');
        const flashcardNextButton = document.getElementById('flashcard-next-button');
        const flashcardCompletionOptions = document.getElementById('flashcard-completion-options');
        const flashcardFinishPracticeButton = document.getElementById('flashcard-finish-practice-button');
        const flashcardFinishMenuButton = document.getElementById('flashcard-finish-menu-button');
        const newWordsInputArea = document.getElementById('new-words-input-area');
        const wordInput = document.getElementById('word-input');
        const selectFileButton = document.getElementById('select-file-button');
        const uploadConfirmButton = document.getElementById('upload-confirm-button');
        const uploadStatus = document.getElementById('upload-status');
        const fileUpload = document.getElementById('file-upload');
        const startButton = document.getElementById('start-button');
        const autoSpeakCheckbox = document.getElementById('auto-speak-checkbox'); 
        const googleTtsCheckbox = document.getElementById('google-tts-checkbox');
        const showExampleSentenceCheckbox = document.getElementById('show-example-sentence-checkbox');
        const newWordsRadio = document.getElementById('new-words-radio'); 
        const wrongWordsRadio = document.getElementById('wrong-words-radio'); 
        const wrongWordsCountSpan = document.getElementById('wrong-words-count');
        const wordLibraryRadio = document.getElementById('word-library-radio');
        const mcQuizRadio = document.getElementById('mc-quiz-radio');
        const typingPracticeRadio = document.getElementById('typing-practice-radio');
        const simpleModeArea = document.getElementById('simple-mode-area');
        const commonSettings = document.getElementById('common-settings');
        const progressText = document.getElementById('progress');
        const backToMenuButton = document.getElementById('back-to-menu-button');
        const chinesePrompt = document.getElementById('chinese-prompt');
        const englishInput = document.getElementById('english-input');
        const feedback = document.getElementById('feedback');
        const checkButton = document.getElementById('check-button');
        const nextButton = document.getElementById('next-button');
        const speakAgainButton = document.getElementById('speak-again-button'); 
        const scoreDisplay = document.getElementById('score-display');
        const wrongWordsList = document.getElementById('wrong-words-list');
        const restartButton = document.getElementById('restart-button');
        const inlineWrongWordsSelection = document.getElementById('inline-wrong-words-selection');
        const inlineWrongWordsSessionsList = document.getElementById('inline-wrong-words-sessions-list');
        const messageDialog = document.getElementById('message-dialog');
        const messageDialogText = document.getElementById('message-dialog-text');
        const messageDialogCloseButton = document.getElementById('message-dialog-close-button');
        const exampleSentenceContainer = document.getElementById('example-sentence-container');
        const englishExampleSentence = document.getElementById('english-example-sentence');
        const chineseExampleSentence = document.getElementById('chinese-example-sentence');
        const wordLibrarySelectionArea = document.getElementById('word-library-selection-area');
        const selectedLibraryDisplay = document.getElementById('selected-library-display');
        const selectLibraryForPracticeButton = document.getElementById('select-library-for-practice-button'); 
        const openManageModalButton = document.getElementById('open-manage-modal-button'); 
        const wordLibraryModal = document.getElementById('word-library-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalCloseButton = document.getElementById('modal-close-button');
        const manageView = document.getElementById('manage-view');
        const selectView = document.getElementById('select-view');
        const librarySelectionTree = document.getElementById('library-selection-tree');
        const selectedWordCountSpan = document.getElementById('selected-word-count');
        const confirmLibrarySelectionButton = document.getElementById('confirm-library-selection-button');
        const newLibraryNameInput = document.getElementById('new-library-name-input');
        const createLibraryButton = document.getElementById('create-library-button');
        const librariesList = document.getElementById('libraries-list');
        const subsetManagementSection = document.getElementById('subset-management-section');
        const currentLibraryNameSpan = document.getElementById('current-library-name');
        const newSubsetNameInput = document.getElementById('new-subset-name-input');
        const createSubsetButton = document.getElementById('create-subset-button');
        const subsetsList = document.getElementById('subsets-list');
        const wordsManagementSection = document.getElementById('words-management-section');
        const currentSubsetNameSpan = document.getElementById('current-subset-name');
        const subsetWordsInput = document.getElementById('subset-words-input');
        const saveSubsetWordsButton = document.getElementById('save-subset-words-button');
        const selectSubsetFileButton = document.getElementById('select-subset-file-button');
        const uploadSubsetConfirmButton = document.getElementById('upload-subset-confirm-button');
        const subsetUploadStatus = document.getElementById('subset-upload-status');
        const subsetFileUpload = document.getElementById('subset-file-upload');
        const multipleChoiceSetupArea = document.getElementById('multiple-choice-setup-area');
        const mcSourceRadios = document.querySelectorAll('input[name="mc-source"]');
        const mcRandomOptions = document.getElementById('mc-random-options');
        const mcManualOptions = document.getElementById('mc-manual-options');
        const randomWordCountInput = document.getElementById('random-word-count-input');
        const totalWordCountSpan = document.getElementById('total-word-count');
        const selectMcWordsButton = document.getElementById('select-mc-words-button');
        const mcSelectedDisplay = document.getElementById('mc-selected-display');
        const mcProgress = document.getElementById('mc-progress');
        const mcBackToMenuButton = document.getElementById('mc-back-to-menu-button');
        const mcSpeakButton = document.getElementById('mc-speak-button');
        const mcOptionsContainer = document.getElementById('mc-options-container');
        const mcFeedback = document.getElementById('mc-feedback');
        const mcNextButton = document.getElementById('mc-next-button');
        const nextCharIndicator = document.getElementById('next-char-indicator');
        const typingInfo = document.getElementById('typing-info');
        const leaderboardListsContainer = document.getElementById('leaderboard-lists-container');
        const typingBackButton = document.getElementById('typing-back-button');
        const profileSection = document.getElementById('profile-section');
        const currentProfileNameSpan = document.getElementById('current-profile-name');
        const profileSelect = document.getElementById('profile-select');
        const newProfileNameInput = document.getElementById('new-profile-name-input');
        const setProfileButton = document.getElementById('set-profile-button');
        const persistentProfileDisplay = document.getElementById('persistent-profile-display');
        const modeSelectTypingWithWords = document.getElementById('mode-select-typing-with-words');
        const typingRepetitionSetup = document.getElementById('typing-repetition-setup');
        const startTypingWithWordsPractice = document.getElementById('start-typing-with-words-practice');
        const cancelTypingWithWordsSetup = document.getElementById('cancel-typing-with-words-setup');
        const customRepetitionInput = document.getElementById('custom-repetition-input');
        const repetitionRadios = document.querySelectorAll('input[name="repetition-count"]');
        // MODIFICATION START: Get new elements
        const advancedTypingRadio = document.getElementById('advanced-typing-radio');
        const advancedTypingSetupArea = document.getElementById('advanced-typing-setup-area');
        const advancedTypingSection = document.getElementById('advanced-typing-section');
        const advancedTypingPrompt = document.getElementById('advanced-typing-prompt');
        const advancedTypingFeedback = document.getElementById('advanced-typing-feedback');
        const advancedTypingBackButton = document.getElementById('advanced-typing-back-button');
        // MODIFICATION END


        // --- Firebase Initialization & Data Loading ---
        const initFirebase = async () => {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }
                    isAuthReady = true;
                    console.log("Firebase Ready. User ID:", userId);

                    await initUserProfile(); 

                    loadPracticeSessionsFromFirestore();
                    loadAllWordsFromLibrary(); 
                    loadTypingScoresFromFirestore(); 
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showMessage("Firebase åˆå§‹åŒ–å¤±è´¥ã€‚å•è¯åº“å’Œæ’è¡Œæ¦œåŠŸèƒ½å°†ä¸å¯ç”¨ã€‚");
                isAuthReady = true; 
            }
        };
        
        const loadAllWordsFromLibrary = async () => {
             if (!isAuthReady) return;
             try {
                const wordsSnapshot = await getDocs(query(collection(db, PUBLIC_WORDS_COLLECTION)));
                allWordsFromLibrary = wordsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                totalWordCountSpan.textContent = allWordsFromLibrary.length;
                console.log(`Loaded ${allWordsFromLibrary.length} total words from library.`);
             } catch (e) {
                console.error("Error loading all words from library:", e);
                totalWordCountSpan.textContent = 'N/A';
             }
        };

        initFirebase();


        // --- Gemini API Configuration ---
        const API_KEY = "AIzaSyA8xQDv2G067hky7jECUaKOJrb3fpsBamc"; 
        const API_URL_TEXT = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;
        
        // --- Custom Message Dialog Function ---
        const showMessage = (message, onOk = null) => {
            messageDialogText.innerHTML = message;
            messageDialog.style.display = 'flex';
            
            // If a callback is provided, use it. Otherwise, just hide.
            messageDialogCloseButton.onclick = () => {
                if (onOk) {
                    onOk();
                }
                messageDialog.style.display = 'none';
                 // Reset to default behavior
                messageDialogCloseButton.onclick = () => messageDialog.style.display = 'none';
            };
        };


        // --- Audio Context Unlock & Sound Generation ---
        const unlockAudioContext = () => {
            if (isAudioContextUnlocked || !window.AudioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const silentAudio = new Audio("data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhIAAAAAA=");
                silentAudio.play().then(() => {
                    isAudioContextUnlocked = true;
                    console.log("Audio context unlocked successfully.");
                }).catch(error => {
                    console.warn("Could not unlock audio context on first try:", error);
                });
            } catch (e) {
                console.error("Could not create AudioContext:", e);
            }
        };
        
        const playErrorSound = () => {
            if (!audioContext || !isAudioContextUnlocked) {
                console.warn("Audio context not ready, cannot play error sound.");
                return;
            }
            let oscillator = audioContext.createOscillator();
            let gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01); 
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
            oscillator.type = 'triangle'; 
            oscillator.start(audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.2);
            oscillator.stop(audioContext.currentTime + 0.2);
        };


        // --- User Profile Management ---
        const initUserProfile = async () => {
            if (!isAuthReady || !userId) return;

            const profilesCollectionPath = `${USER_PROFILES_COLLECTION_BASE}${userId}/profiles`;
            try {
                const querySnapshot = await getDocs(collection(db, profilesCollectionPath));
                allUserProfiles = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error("Error fetching user profiles:", error);
                showMessage("æ— æ³•åŠ è½½ç”¨æˆ·åˆ—è¡¨ã€‚");
            }
            
            updateProfileUI();

            const lastProfile = localStorage.getItem('currentUserProfile');
            if (lastProfile && allUserProfiles.some(p => p.name === lastProfile)) {
                currentUserProfile = lastProfile;
                profileSelect.value = lastProfile;
            } else if (allUserProfiles.length > 0) {
                currentUserProfile = allUserProfiles[0].name;
                profileSelect.value = currentUserProfile;
            } else {
                currentUserProfile = null;
            }

            updateAllProfileDisplays();
            if (!currentUserProfile) {
                showMessage("æ¬¢è¿ä½¿ç”¨ï¼è¯·å…ˆé€‰æ‹©æˆ–åˆ›å»ºä¸€ä¸ªç»ƒä¹ ç”¨æˆ·åï¼Œä»¥ä¾¿è®°å½•æ‚¨çš„ç»ƒä¹ è¿›åº¦ã€‚");
            }
        };

        const updateProfileUI = () => {
            profileSelect.innerHTML = '<option value="">-- é€‰æ‹©å·²æœ‰ç”¨æˆ· --</option>';
            allUserProfiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.name;
                option.textContent = profile.name;
                profileSelect.appendChild(option);
            });
        };

        const updateAllProfileDisplays = () => {
            const profileText = currentUserProfile || 'æœªé€‰æ‹©';
            currentProfileNameSpan.textContent = profileText;
            persistentProfileDisplay.innerHTML = `ç»ƒä¹ ç”¨æˆ·: <strong>${profileText}</strong>`;
        };

        const handleSetProfile = async () => {
            const selectedProfile = profileSelect.value;
            const newProfile = newProfileNameInput.value.trim();

            if (newProfile) {
                if (allUserProfiles.some(p => p.name.toLowerCase() === newProfile.toLowerCase())) {
                    showMessage(`ç”¨æˆ·å "${newProfile}" å·²å­˜åœ¨ã€‚`);
                    return;
                }
                showLoader('æ­£åœ¨åˆ›å»ºç”¨æˆ·...');
                try {
                    const profilesCollectionPath = `${USER_PROFILES_COLLECTION_BASE}${userId}/profiles`;
                    await addDoc(collection(db, profilesCollectionPath), { name: newProfile, createdAt: serverTimestamp() });
                    currentUserProfile = newProfile;
                    localStorage.setItem('currentUserProfile', newProfile);
                    newProfileNameInput.value = '';
                    await initUserProfile(); 
                    profileSelect.value = newProfile; 
                } catch (error) {
                    console.error("Error creating profile:", error);
                    showMessage("åˆ›å»ºç”¨æˆ·å¤±è´¥ã€‚");
                } finally {
                    hideLoader();
                }
            } else if (selectedProfile) {
                currentUserProfile = selectedProfile;
                localStorage.setItem('currentUserProfile', selectedProfile);
            } else {
                showMessage("è¯·é€‰æ‹©ä¸€ä¸ªå·²æœ‰ç”¨æˆ·æˆ–è¾“å…¥ä¸€ä¸ªæ–°ç”¨æˆ·åã€‚");
                return;
            }
            updateAllProfileDisplays();
            showMessage(`ç”¨æˆ·å·²åˆ‡æ¢ä¸º: <strong>${currentUserProfile}</strong>`);
        };

        setProfileButton.addEventListener('click', handleSetProfile);
        profileSelect.addEventListener('change', () => {
            if (profileSelect.value) {
                newProfileNameInput.value = '';
            }
        });


        // --- Firestore-based Session Management Functions ---
        const loadPracticeSessionsFromFirestore = async () => {
            if (!isAuthReady || !userId) return;
            showLoader('æ­£åœ¨åŠ è½½é”™é¢˜è®°å½•...');
            try {
                const sessionsCollectionPath = `${USER_SESSIONS_COLLECTION_BASE}${userId}/practiceSessions`;
                const q = query(collection(db, sessionsCollectionPath), orderBy("endTime", "desc"));
                const querySnapshot = await getDocs(q);

                allPracticeSessions = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                const overallUniqueWrongWordsMap = new Map();
                allPracticeSessions.forEach(session => {
                    if(session.sessionWords && Array.isArray(session.sessionWords)) {
                        session.sessionWords.forEach(word => {
                            if (!word.wasCorrect) {
                                if (!overallUniqueWrongWordsMap.has(word.english) || overallUniqueWrongWordsMap.get(word.english).timestamp < session.endTime.toMillis()) {
                                    overallUniqueWrongWordsMap.set(word.english, {
                                        english: word.english,
                                        chinese: word.chinese,
                                        timestamp: session.endTime.toMillis()
                                    });
                                }
                            }
                        });
                    }
                });
                persistentWrongWords = Array.from(overallUniqueWrongWordsMap.values());
                wrongWordsCountSpan.textContent = persistentWrongWords.length;
                wrongWordsRadio.disabled = persistentWrongWords.length === 0;

            } catch (error) {
                console.error("Error loading practice sessions from Firestore:", error);
                showMessage("åŠ è½½é”™é¢˜è®°å½•å¤±è´¥ã€‚è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥ã€‚");
            } finally {
                hideLoader();
                updateStartButtonState();
            }
        };

        const savePracticeSessionToFirestore = async () => {
            if (!isAuthReady || !userId || words.length === 0) return;

            const quizEndTime = new Date();
            const totalDurationSeconds = (quizEndTime - quizStartTime) / 1000;
            const accuracy = score / words.length;

            const sessionData = {
                ...currentQuizDetails,
                userId: userId,
                profileName: currentUserProfile || 'Anonymous', 
                startTime: quizStartTime,
                endTime: quizEndTime,
                totalDurationSeconds: totalDurationSeconds,
                score: score,
                totalWords: words.length,
                accuracy: accuracy,
                // For "Typing with Words" mode, save an empty array so wrong words are not recorded.
                sessionWords: isTypingWithWordsMode ? [] : words.map(w => ({
                    english: w.english,
                    chinese: w.chinese,
                    wasCorrect: w.wasCorrect || false,
                    timeTakenSeconds: w.timeTakenSeconds || 0
                }))
            };

            try {
                const sessionsCollectionPath = `${USER_SESSIONS_COLLECTION_BASE}${userId}/practiceSessions`;
                await addDoc(collection(db, sessionsCollectionPath), sessionData);
                console.log("Practice session saved to Firestore.");
            } catch (error) {
                console.error("Error saving practice session to Firestore:", error);
                showMessage("æ— æ³•ä¿å­˜æœ¬æ¬¡ç»ƒä¹ è®°å½•ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚");
            } finally {
                await loadPracticeSessionsFromFirestore();
            }
        };


        // --- Utility Functions ---
        const showLoader = (text) => { loaderText.textContent = text; loader.style.display = 'flex'; };
        const hideLoader = () => { loader.style.display = 'none'; };
        const fileToBase64 = (file) => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = error => reject(error);
        });

        const parseWordInput = (text) => {
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            return lines.map(line => {
                const parts = line.split('#').map(part => part.trim());
                if (parts.length >= 2 && parts[0] && parts[1]) {
                    return { english: parts[0], chinese: parts[1] };
                } else if (parts.length === 1 && parts[0]) {
                    return { english: parts[0], chinese: null };
                }
                return null;
            }).filter(Boolean);
        };

        const speak = async (text) => {
            if (!audioPlayer.paused) audioPlayer.pause();
            unlockAudioContext();

            if (googleTranslateTtsEnabled) {
                let audioBlob = audioCache.get(text);
                if (!audioBlob) {
                    try {
                        const targetUrl = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(text)}&tl=en&client=tw-ob`;
                        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`;
                        const response = await fetch(proxyUrl);
                        if (!response.ok) throw new Error('è·å–éŸ³é¢‘æ–‡ä»¶å¤±è´¥');
                        audioBlob = await response.blob();
                        audioCache.set(text, audioBlob);
                    } catch (error) {
                        console.error("æ’­æ”¾ Google TTS éŸ³é¢‘æ—¶å‡ºé”™:", error);
                        showMessage("æ— æ³•åŠ è½½å•è¯å‘éŸ³ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚");
                        return;
                    }
                }
                const audioUrl = URL.createObjectURL(audioBlob);
                audioPlayer.src = audioUrl;
                audioPlayer.play().catch(e => console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", e));
            } else if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                utterance.rate = 0.9;
                window.speechSynthesis.speak(utterance);
            } else {
                showMessage('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åŠŸèƒ½ã€‚');
            }
        };

        // --- Gemini API Calls ---
        const extractTextFromFile = async (base64Data, mimeType) => {
            const payload = {
                contents: [{
                    parts: [
                        // MODIFIED: æŒ‡ç¤º AI ä½¿ç”¨ # ä½œä¸ºåˆ†éš”ç¬¦
                        { text: "Extract all text from the provided file. If the file contains English words, with or without Chinese translations, list them in a clean format (e.g., one word or 'English#Chinese' pair per line). If no clear word pairs are found, return the raw text content." },
                        { inlineData: { mimeType: mimeType, data: base64Data } }
                    ]
                }]
            };
            const response = await fetch(API_URL_TEXT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`Gemini API Error: ${response.statusText}`);
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) throw new Error("Could not extract text from the file.");
            return text;
        };

        const callGeminiForTranslation = async (englishWordsOnly) => {
            const prompt = `Translate the following English words to Chinese. Provide the response as a valid JSON array of objects, where each object has 'english' and 'chinese' keys. Words: ${JSON.stringify(englishWordsOnly)}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "OBJECT", properties: { "english": { "type": "STRING" }, "chinese": { "type": "STRING" } }, required: ["english", "chinese"] } } }
            };
            const response = await fetch(API_URL_TEXT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not get translations.");
            return JSON.parse(jsonText);
        };

        const callGeminiForVerification = async (wordsWithProvidedChinese) => {
            const formattedWords = wordsWithProvidedChinese.map(w => ({ english: w.english, provided_chinese: w.chinese }));
            const prompt = `For each English word and its provided Chinese translation, indicate if the translation is accurate. If not, provide the correct translation. Format the response as a valid JSON array of objects, where each object has 'english', 'provided_chinese', 'is_accurate' (boolean), and 'correct_chinese' (string, only if not accurate). Words: ${JSON.stringify(formattedWords)}`;
            
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { 
                    responseMimeType: "application/json", 
                    responseSchema: { 
                        type: "ARRAY", 
                        items: { 
                            type: "OBJECT", 
                            properties: { 
                                "english": { "type": "STRING" }, 
                                "provided_chinese": { "type": "STRING" },
                                "is_accurate": { "type": "BOOLEAN" },
                                "correct_chinese": { "type": "STRING" } 
                            }, 
                            required: ["english", "provided_chinese", "is_accurate"] 
                        } 
                    } 
                }
            };
            const response = await fetch(API_URL_TEXT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not get verification results.");
            return JSON.parse(jsonText);
        };

        const callGeminiForExampleSentenceAndTranslation = async (englishWord) => {
            const prompt = `Please generate a simple and common English example sentence for the word '${englishWord}'. Immediately after the English sentence, provide its Chinese translation. Format the response as a JSON object with 'englishSentence' and 'chineseSentence' keys.`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "englishSentence": { "type": "STRING" },
                            "chineseSentence": { "type": "STRING" }
                        },
                        required: ["englishSentence", "chineseSentence"]
                    }
                }
            };
            const response = await fetch(API_URL_TEXT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not generate example sentence and translation.");
            return JSON.parse(jsonText);
        };

        const callGeminiForFlashcardData = async (englishWord) => {
            const prompt = `For the English word "${englishWord}", provide the following information:
1.  The word with syllable breaks (using a hyphen, e.g., "beau-ti-ful").
2.  The primary part of speech (e.g., "noun", "verb", "adjective").
3.  The Chinese translation.
4.  A simple English example sentence.
5.  The Chinese translation of the example sentence.

Format the response as a single, valid JSON object with these exact keys: "syllables", "partOfSpeech", "chinese", "englishSentence", "chineseSentence".`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "syllables": { "type": "STRING" },
                            "partOfSpeech": { "type": "STRING" },
                            "chinese": { "type": "STRING" },
                            "englishSentence": { "type": "STRING" },
                            "chineseSentence": { "type": "STRING" }
                        },
                        required: ["syllables", "partOfSpeech", "chinese", "englishSentence", "chineseSentence"]
                    }
                }
            };
             const response = await fetch(API_URL_TEXT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not generate flashcard data.");
            return JSON.parse(jsonText);
        };
        
        const callGeminiForBatchMcqOptions = async (wordList, allQuizWords) => {
            const prompt = `For each word in the following list, generate three incorrect multiple-choice options (distractors).
1. One distractor should be a real English word that looks or sounds similar to the original word.
2. The other two distractors should be common, real English words.
3. IMPORTANT: None of the generated distractors should be any of these words: ${JSON.stringify(allQuizWords)}.

Word list: ${JSON.stringify(wordList)}

Provide the response as a single, valid JSON array of objects. Each object must have these exact keys: "original_word" and "distractors" (which is an array of three strings).`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "original_word": { "type": "STRING" },
                                "distractors": {
                                    type: "ARRAY",
                                    items: { "type": "STRING" }
                                }
                            },
                            required: ["original_word", "distractors"]
                        }
                    }
                }
            };
            const response = await fetch(API_URL_TEXT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Could not generate batch MCQ options.");
            return JSON.parse(jsonText);
        };


        const processWordsForQuiz = async (inputWords) => {
            const wordsWithoutChinese = inputWords.filter(w => !w.chinese);
            const wordsWithChinese = inputWords.filter(w => w.chinese);

            let translatedWords = [];
            let wordsToReturn = [...wordsWithChinese]; 

            if (wordsWithoutChinese.length > 0) {
                showLoader('æ­£åœ¨ç¿»è¯‘æ–°å•è¯...');
                const englishOnlyList = wordsWithoutChinese.map(w => w.english);
                try {
                    translatedWords = await callGeminiForTranslation(englishOnlyList);
                    wordsToReturn = [...wordsToReturn, ...translatedWords];
                } catch (error) {
                    console.error("ç¿»è¯‘æ–°å•è¯æ—¶å‡ºé”™:", error);
                    showMessage("ç¿»è¯‘æ–°å•è¯æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–é‡è¯•ã€‚");
                    return [];
                }
            }

            if (wordsWithChinese.length > 0) {
                showLoader('æ­£åœ¨éªŒè¯å·²æœ‰ç¿»è¯‘...');
                try {
                    const verifiedResults = await callGeminiForVerification(wordsWithChinese);
                    
                    verifiedResults.forEach(verifiedWord => {
                        if (!verifiedWord.is_accurate) {
                            const message = `ç¿»è¯‘ä¸å‡†ç¡®ï¼š<br>è‹±æ–‡: <strong>${verifiedWord.english}</strong><br>æ‚¨æä¾›çš„ä¸­æ–‡: <strong>${verifiedWord.provided_chinese}</strong><br>æ­£ç¡®ç¿»è¯‘åº”ä¸º: <strong>${verifiedWord.correct_chinese}</strong>ã€‚å·²è‡ªåŠ¨æ›´æ–°ã€‚`;
                            showMessage(message);
                            const wordInList = wordsToReturn.find(w => w.english === verifiedWord.english);
                            if (wordInList) {
                                wordInList.chinese = verifiedWord.correct_chinese;
                            }
                        }
                    });
                } catch (error) {
                    console.error("éªŒè¯å·²æœ‰ç¿»è¯‘æ—¶å‡ºé”™:", error);
                    showMessage("éªŒè¯å·²æœ‰ç¿»è¯‘æ—¶å‘ç”Ÿé”™è¯¯ï¼Œå°†ä½¿ç”¨æ‚¨æä¾›çš„ç¿»è¯‘ã€‚");
                }
            }

            const finalWordsMap = new Map();
            wordsToReturn.forEach(word => {
                finalWordsMap.set(word.english.toLowerCase(), word);
            });

            return Array.from(finalWordsMap.values());
        };


        // --- Main Application Flow & Page Switching ---
        const showPage = (pageId) => {
            [setupSection, quizSection, completionSection, modeSelectionSection, flashcardSection, mcQuizSection, typingPracticeSection, advancedTypingSection].forEach(sec => sec.style.display = 'none');
            
            const targetSection = document.getElementById(pageId);
            if (targetSection) {
                const flexSections = ['flashcard-section', 'typing-practice-section', 'setup-section', 'advanced-typing-section'];
                targetSection.style.display = flexSections.includes(pageId) ? 'flex' : 'block';
            }

            persistentProfileDisplay.style.display = (pageId === 'setup-section') ? 'none' : 'block';
        };

        const startQuiz = () => {
            if (words.length === 0) { showMessage('æ²¡æœ‰å¯ä¾›ç»ƒä¹ çš„å•è¯ã€‚'); return; }
            exampleSentenceCache.clear();
            quizStartTime = new Date();
            currentWordIndex = 0;
            score = 0;
            
            if (isTypingWithWordsMode) {
                 currentQuizDetails = { practiceMode: 'çœ‹è¯æ‰“å­—ç»ƒä¹ ' };
            } else {
                currentQuizDetails = { practiceMode: 'å•è¯æ‹¼å†™' };
                if (wrongWordsRadio.checked) currentQuizDetails.practiceMode = 'é”™é¢˜ç»ƒä¹ ';
                else if (wordLibraryRadio.checked) currentQuizDetails.practiceMode = 'å•è¯åº“æ‹¼å†™';
            }

            words.forEach(word => { word.wasCorrect = false; word.timeTakenSeconds = 0; });
            // For typing mode, we don't shuffle because the words are already ordered by repetition
            if (!isTypingWithWordsMode) {
                shuffleArray(words);
            }
            showPage('quiz-section');
            showNextWord();
        };

        // --- Quiz Logic ---
        const checkAnswer = async () => {
            const timeTakenSeconds = (performance.now() - wordStartTime) / 1000;
            words[currentWordIndex].timeTakenSeconds = timeTakenSeconds;

            const userAnswer = englishInput.value.trim().toLowerCase();
            const correctAnswer = words[currentWordIndex].english.toLowerCase();
            
            if (userAnswer === '') { feedback.textContent = 'è¯·è¾“å…¥ç­”æ¡ˆï¼'; feedback.className = ''; return; }

            if (userAnswer === correctAnswer) {
                score++;
                words[currentWordIndex].wasCorrect = true;
                feedback.innerHTML = `âœ” æ­£ç¡®! <span style="font-size: 0.8em; color: #555;">(${timeTakenSeconds.toFixed(2)}s)</span>`;
                feedback.className = 'correct';
            } else {
                words[currentWordIndex].wasCorrect = false;
                const currentWord = words[currentWordIndex];
                feedback.innerHTML = `âŒ é”™è¯¯ï¼æ­£ç¡®ç­”æ¡ˆæ˜¯: <strong style="color: #333;">${currentWord.english}</strong> <span style="font-size: 0.8em; color: #555;">(${timeTakenSeconds.toFixed(2)}s)</span>`;
                feedback.className = 'incorrect';
            }

            englishInput.disabled = true;
            checkButton.style.display = 'none';
            nextButton.style.display = 'block';
            nextButton.focus();
            
            if (!isTypingWithWordsMode && showExampleSentenceEnabled) {
                 await showExampleSentenceForWord(words[currentWordIndex]);
            }
        };

        const showExampleSentenceForWord = async (word) => {
            if (exampleSentenceCache.has(word.english)) {
                const data = exampleSentenceCache.get(word.english);
                englishExampleSentence.textContent = data.englishSentence;
                chineseExampleSentence.textContent = data.chineseSentence;
                exampleSentenceContainer.style.display = 'block';
                return;
            }
        
            const loaderTimeout = setTimeout(() => showLoader('æ­£åœ¨ç”Ÿæˆä¾‹å¥...'), 300);
            try {
                const data = await callGeminiForExampleSentenceAndTranslation(word.english);
                exampleSentenceCache.set(word.english, data);
                englishExampleSentence.textContent = data.englishSentence;
                chineseExampleSentence.textContent = data.chineseSentence;
                exampleSentenceContainer.style.display = 'block';
            } catch (error) {
                console.error("ç”Ÿæˆä¾‹å¥æ—¶å‡ºé”™:", error);
                exampleSentenceContainer.style.display = 'none';
            } finally {
                clearTimeout(loaderTimeout);
                hideLoader();
            }
        };

        const showNextWord = async () => {
            if (currentWordIndex < words.length) {
                const word = words[currentWordIndex];
                progressText.textContent = `ç¬¬ ${currentWordIndex + 1} / ${words.length} é¢˜`;
                
                if (isTypingWithWordsMode) {
                    chinesePrompt.innerHTML = `<span style="display: block; font-size: 1.5rem; color: #6c757d; margin-bottom: 10px; font-weight: normal; letter-spacing: 1px;">${word.english}</span><span>${word.chinese}</span>`;
                    if (showExampleSentenceEnabled) {
                        await showExampleSentenceForWord(word);
                    } else {
                        exampleSentenceContainer.style.display = 'none';
                    }
                } else {
                    chinesePrompt.textContent = word.chinese;
                    exampleSentenceContainer.style.display = 'none';
                }
                
                englishInput.placeholder = '_ '.repeat(word.english.length).trim();
                englishInput.value = '';
                englishInput.disabled = false;
                feedback.textContent = '';
                checkButton.style.display = 'block';
                nextButton.style.display = 'none';
                englishInput.focus();
                wordStartTime = performance.now();
                if (autoSpeakEnabled) speak(word.english);
            } else {
                showCompletionScreen();
            }
        };

        const showCompletionScreen = async () => {
            if (currentQuizDetails.practiceMode) await savePracticeSessionToFirestore();
            showPage('completion-section');
            const totalDurationSeconds = words.length > 0 ? (new Date() - quizStartTime) / 1000 : 0;
            const averageTimePerWord = words.length > 0 ? words.reduce((acc, word) => acc + (word.timeTakenSeconds || 0), 0) / words.length : 0;
            const percentage = words.length > 0 ? Math.round((score / words.length) * 100) : 0;
            scoreDisplay.innerHTML = `ä½ ç­”å¯¹äº† <strong>${score}</strong> é“é¢˜ï¼Œå…± <strong>${words.length}</strong> é“ã€‚<br>æ­£ç¡®ç‡: <strong>${percentage}%</strong><br>æ€»ç”¨æ—¶: <strong>${totalDurationSeconds.toFixed(2)}</strong> ç§’<br>å¹³å‡ç”¨æ—¶: <strong>${averageTimePerWord.toFixed(2)}</strong> ç§’/è¯`;
            wrongWordsList.innerHTML = '';
            const sessionWrongWords = words.filter(word => !word.wasCorrect);
            if (sessionWrongWords.length > 0) {
                let html = '<h3>æœ¬æ¬¡é”™é¢˜ï¼š</h3><ul>';
                sessionWrongWords.forEach(word => {
                    html += `<li><strong>${word.english}</strong>: ${word.chinese} (${(word.timeTakenSeconds || 0).toFixed(2)}s)</li>`;
                });
                wrongWordsList.innerHTML = html + '</ul>';
            } else if (words.length > 0) {
                wrongWordsList.innerHTML = '<p style="color: #28a745; font-weight: bold;">å¤ªæ£’äº†ï¼Œå…¨éƒ¨æ­£ç¡®ï¼</p>';
            }
        };

        checkButton.addEventListener('click', checkAnswer);
        englishInput.addEventListener('keyup', (event) => { if (event.key === 'Enter' && !englishInput.disabled) checkAnswer(); });
        nextButton.addEventListener('click', () => { currentWordIndex++; showNextWord(); });
        speakAgainButton.addEventListener('click', () => { if(currentWordIndex < words.length) speak(words[currentWordIndex].english); });
        backToMenuButton.addEventListener('click', showCompletionScreen);

        // --- Flashcard Logic ---
        const startFlashcards = () => {
            unlockAudioContext();
            autoSpeakEnabled = autoSpeakCheckbox.checked;
            currentFlashcardIndex = 0;
            flashcardCompletionOptions.style.display = 'none';
            flashcardNav.style.display = 'flex';
            showPage('flashcard-section');
            showFlashcard(currentFlashcardIndex);
        };

        const showFlashcard = async (index) => {
            if (index >= words.length) {
                flashcardNav.style.display = 'none';
                flashcardCompletionOptions.style.display = 'flex';
                flashcardContent.style.display = 'none';
                flashcardProgress.textContent = `å¤ä¹ å®Œæ¯• (${words.length} / ${words.length})`;
                return;
            }
            flashcardProgress.textContent = `å•è¯å¡ ${index + 1} / ${words.length}`;
            flashcardPrevButton.disabled = (index === 0);
            flashcardNextButton.textContent = (index === words.length - 1) ? 'å®Œæˆå¤ä¹ ' : 'ä¸‹ä¸€ä¸ª';
            const currentWord = words[index];
            if (currentWord.flashcardData) {
                populateFlashcard(currentWord.flashcardData);
                if (autoSpeakEnabled) speak(currentWord.english);
                return;
            }
            flashcardSpinner.style.display = 'flex';
            flashcardContent.style.display = 'none';
            try {
                const data = await callGeminiForFlashcardData(currentWord.english);
                data.chinese = currentWord.chinese || data.chinese;
                currentWord.flashcardData = data; 
                populateFlashcard(data);
                if (autoSpeakEnabled) speak(currentWord.english);
            } catch (error) {
                console.error("Error fetching flashcard data:", error);
                showMessage(`æ— æ³•åŠ è½½å•è¯ "${currentWord.english}" çš„è¯¦ç»†ä¿¡æ¯ã€‚`);
                populateFlashcard({ syllables: currentWord.english, partOfSpeech: 'N/A', chinese: currentWord.chinese, englishSentence: 'Could not load example.', chineseSentence: 'æ— æ³•åŠ è½½ä¾‹å¥ã€‚' });
            } finally {
                flashcardSpinner.style.display = 'none';
                flashcardContent.style.display = 'block';
            }
        };

        const populateFlashcard = (data) => {
            flashcardWord.textContent = data.syllables;
            flashcardPos.textContent = data.partOfSpeech;
            flashcardChinese.textContent = data.chinese;
            flashcardExampleEng.textContent = data.englishSentence;
            flashcardExampleChn.textContent = data.chineseSentence;
        };

        flashcardPrevButton.addEventListener('click', () => { if (currentFlashcardIndex > 0) { currentFlashcardIndex--; showFlashcard(currentFlashcardIndex); } });
        flashcardNextButton.addEventListener('click', () => { currentFlashcardIndex++; showFlashcard(currentFlashcardIndex); });
        flashcardSpeakButton.addEventListener('click', () => { if (currentFlashcardIndex < words.length) speak(words[currentFlashcardIndex].english); });
        flashcardFinishPracticeButton.addEventListener('click', startQuiz);
        flashcardBackToMenuButton.addEventListener('click', () => { restartButton.click(); });
        flashcardFinishMenuButton.addEventListener('click', () => { restartButton.click(); });

        // --- Multiple Choice Quiz Logic (MODIFIED for Performance) ---
        const startMcQuiz = async () => {
            if (words.length === 0) { showMessage('æ²¡æœ‰å¯ä¾›ç»ƒä¹ çš„å•è¯ã€‚'); return; }
            showLoader('æ­£åœ¨ä¸ºé€‰æ‹©é¢˜ç”Ÿæˆé€‰é¡¹...');

            try {
                // Step 1: Identify words that need options generated.
                const wordsToProcess = words.filter(word => !word.mcOptions);

                if (wordsToProcess.length > 0) {
                    // Step 2: Batch generate all distractors in one API call.
                    const wordsToProcessList = wordsToProcess.map(w => w.english);
                    const allQuizWordsList = words.map(w => w.english);
                    const batchDistractorsResult = await callGeminiForBatchMcqOptions(wordsToProcessList, allQuizWordsList);

                    // Create a map for easy lookup of generated distractors.
                    const distractorsMap = new Map(batchDistractorsResult.map(item => [item.original_word.toLowerCase(), item.distractors]));

                    // Step 3: Collect all unique distractors that need translation.
                    const allDistractors = new Set();
                    batchDistractorsResult.forEach(item => {
                        item.distractors.forEach(d => allDistractors.add(d));
                    });

                    // Step 4: Batch translate all unique distractors in one API call.
                    const translatedDistractors = await callGeminiForTranslation(Array.from(allDistractors));
                    const translationMap = new Map(translatedDistractors.map(t => [t.english.toLowerCase(), t.chinese]));

                    // Step 5: Populate the mcOptions for each word.
                    wordsToProcess.forEach(word => {
                        const wordDistractors = distractorsMap.get(word.english.toLowerCase());
                        if (wordDistractors) {
                            word.mcOptions = [
                                { english: word.english, chinese: word.chinese },
                                ...wordDistractors.map(d => ({ english: d, chinese: translationMap.get(d.toLowerCase()) || '...' }))
                            ];
                        } else {
                            // Fallback in case a word was missed in the batch result
                            console.warn(`Could not find distractors for ${word.english} in batch result.`);
                            word.mcOptions = [
                                { english: word.english, chinese: word.chinese },
                                { english: "option", chinese: "é€‰é¡¹" },
                                { english: "choice", chinese: "é€‰æ‹©" },
                                { english: "answer", chinese: "ç­”æ¡ˆ" },
                            ];
                        }
                    });
                }
            } catch (error) {
                console.error("Error generating MCQ options:", error);
                showMessage("ç”Ÿæˆé€‰æ‹©é¢˜é€‰é¡¹æ—¶å‡ºé”™ï¼Œè¯·ç¨åé‡è¯•ã€‚");
                hideLoader();
                return;
            }

            hideLoader();
            quizStartTime = new Date();
            currentMcQuizIndex = 0;
            score = 0;
            currentQuizDetails = { practiceMode: 'å•è¯é€‰æ‹©é¢˜' };
            words.forEach(word => { word.wasCorrect = false; word.timeTakenSeconds = 0; });
            shuffleArray(words);
            showPage('mc-quiz-section');
            showNextMcQuestion();
        };


        const showNextMcQuestion = () => {
            if (currentMcQuizIndex >= words.length) { showCompletionScreen(); return; }
            const word = words[currentMcQuizIndex];
            mcProgress.textContent = `ç¬¬ ${currentMcQuizIndex + 1} / ${words.length} é¢˜`;
            mcFeedback.textContent = '';
            mcNextButton.style.display = 'none';
            mcOptionsContainer.innerHTML = '';
            const shuffledOptions = [...word.mcOptions];
            shuffleArray(shuffledOptions);
            shuffledOptions.forEach(option => {
                const button = document.createElement('button');
                button.innerHTML = `${option.english}<br><span style="font-size: 0.8em; color: #666; font-weight: normal;">${option.chinese}</span>`;
                button.className = 'mc-option-button';
                button.dataset.word = option.english;
                mcOptionsContainer.appendChild(button);
                button.addEventListener('click', () => checkMcAnswer(button, word.english));
            });
            wordStartTime = performance.now();
            if(autoSpeakEnabled) speak(word.english);
        };
        
        const checkMcAnswer = (selectedButton, correctAnswer) => {
            const timeTakenSeconds = (performance.now() - wordStartTime) / 1000;
            const currentWord = words[currentMcQuizIndex];
            currentWord.timeTakenSeconds = timeTakenSeconds;
            const isCorrect = selectedButton.dataset.word.toLowerCase() === correctAnswer.toLowerCase();
            Array.from(mcOptionsContainer.children).forEach(button => {
                button.disabled = true;
                if (button.dataset.word.toLowerCase() === correctAnswer.toLowerCase()) button.classList.add('correct-answer');
                else if (button === selectedButton) button.classList.add('wrong-answer');
            });
            if (isCorrect) {
                score++;
                currentWord.wasCorrect = true;
                mcFeedback.innerHTML = `âœ” æ­£ç¡®!`;
                mcFeedback.className = 'correct';
            } else {
                currentWord.wasCorrect = false;
                mcFeedback.innerHTML = `âŒ é”™è¯¯ï¼æ­£ç¡®ç­”æ¡ˆæ˜¯: <strong>${currentWord.english}</strong> (${currentWord.chinese})`;
                mcFeedback.className = 'incorrect';
            }
            mcNextButton.style.display = 'block';
            mcNextButton.focus();
        };
        
        mcSpeakButton.addEventListener('click', () => { if (currentMcQuizIndex < words.length) speak(words[currentMcQuizIndex].english); });
        mcNextButton.addEventListener('click', () => { currentMcQuizIndex++; showNextMcQuestion(); });
        mcBackToMenuButton.addEventListener('click', showCompletionScreen);

        // --- Typing Practice Logic ---
        const startTypingPractice = () => {
            unlockAudioContext(); 
            isTypingPracticeActive = true;
            waitingForRestart = true;
            typingSessionStats = { errors: {}, totalPresses: {} };
            typingInfo.innerHTML = `<p>è¯·æŒ‰ 'a' é”®å¼€å§‹æ–°ä¸€è½®ç»ƒä¹ </p>`;
            nextCharIndicator.style.display = 'none';
            document.addEventListener('keydown', handleTypingKeyPress);
            showPage('typing-practice-section');
        };

        const startNewTypingRound = () => {
            waitingForRestart = false;
            currentTargetCharIndex = 0;
            typingInfo.innerHTML = `<p>æ­£åœ¨è®¡æ—¶... å­—æ¯: <span style="color: #dc3545;">A</span></p>`;
            updateNextCharDisplay();
            typingStartTime = performance.now();
        };
        
        const endTypingRound = () => {
            isTypingPracticeActive = false; 
            const endTime = performance.now();
            const elapsedTime = (endTime - typingStartTime) / 1000;
            let isNewRecord = bestTypingScores.length < 10 || elapsedTime < bestTypingScores[bestTypingScores.length - 1].score;
            let message = `ğŸ‰ å¤ªæ£’äº†ï¼ç”¨æ—¶ <strong>${elapsedTime.toFixed(2)}</strong> ç§’ï¼`;
            if (isNewRecord) {
                message = `<span class="new-record">ğŸ† æ–°çºªå½•ï¼å¤ªå‰å®³äº†ï¼ç”¨æ—¶ <strong>${elapsedTime.toFixed(2)}</strong> ç§’ï¼</span>`;
                saveTypingScoreToFirestore(elapsedTime);
            }
            message += `<br><span style="font-size: 0.8em; color: #666;">è¯·æŒ‰ 'a' é”®å¼€å§‹æ–°ä¸€è½®ç»ƒä¹ </span>`;
            typingInfo.innerHTML = message;
            nextCharIndicator.style.display = 'none';
            waitingForRestart = true;
            isTypingPracticeActive = true; 
        };

        const handleTypingKeyPress = (event) => {
            if (!isTypingPracticeActive || event.key.length > 1) return;
            const keyPressed = event.key.toLowerCase();
            if (waitingForRestart) {
                if (keyPressed === 'a') startNewTypingRound();
                return;
            }
            const targetChar = alphabet[currentTargetCharIndex];
            
            typingSessionStats.totalPresses[targetChar] = (typingSessionStats.totalPresses[targetChar] || 0) + 1;

            if (keyPressed === targetChar) {
                currentTargetCharIndex++;
                if (currentTargetCharIndex < alphabet.length) {
                    updateNextCharDisplay();
                    typingInfo.innerHTML = `<p>æ­£åœ¨è®¡æ—¶... å­—æ¯: <span style="color: #dc3545;">${alphabet[currentTargetCharIndex].toUpperCase()}</span></p>`;
                } else {
                    endTypingRound();
                }
            } else {
                playErrorSound();
                typingSessionStats.errors[targetChar] = (typingSessionStats.errors[targetChar] || 0) + 1;
            }
        };
        
        const updateNextCharDisplay = () => {
            const char = alphabet[currentTargetCharIndex];
            const coords = keyCoordinates[char];
            if (coords) {
                nextCharIndicator.textContent = char.toUpperCase();
                nextCharIndicator.style.top = `${coords.top}%`;
                nextCharIndicator.style.left = `${coords.left}%`;
                nextCharIndicator.style.display = 'flex';
            }
        };

        const loadTypingScoresFromFirestore = () => {
            if (!isAuthReady) return;
            const docRef = doc(db, TYPING_SCORES_DOC);
            onSnapshot(docRef, (docSnap) => {
                bestTypingScores = docSnap.exists() ? (docSnap.data().scores || []) : [];
                displayLeaderboard();
            }, (error) => console.error("Error loading typing scores:", error));
        };

        const saveTypingScoreToFirestore = async (newScore) => {
            if (!isAuthReady) return;
            const newEntry = { score: newScore, date: new Date().toISOString().split('T')[0], user: currentUserProfile || 'Anonymous' }; 
            let updatedScores = [...bestTypingScores, newEntry];
            updatedScores.sort((a, b) => a.score - b.score);
            updatedScores = updatedScores.slice(0, 10);
            try {
                await setDoc(doc(db, TYPING_SCORES_DOC), { scores: updatedScores });
                console.log("Typing score saved successfully.");
            } catch (error) {
                console.error("Error saving typing score:", error);
            }
        };

        const displayLeaderboard = () => {
            leaderboardListsContainer.innerHTML = '';
            if (bestTypingScores.length === 0) {
                leaderboardListsContainer.innerHTML = '<ol><li>æš‚æ— è®°å½•</li></ol>';
                return;
            }

            const list1 = document.createElement('ol');
            const list2 = document.createElement('ol');
            
            bestTypingScores.forEach((entry, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${entry.score.toFixed(2)}s</strong> - ${entry.user || 'anon'}`;
                li.title = `${entry.score.toFixed(2)}s - by ${entry.user || 'Anonymous'} on ${entry.date}`;
                
                if (index < 5) {
                    list1.appendChild(li);
                } else {
                    list2.appendChild(li);
                }
            });

            leaderboardListsContainer.appendChild(list1);
            if (list2.children.length > 0) {
                 leaderboardListsContainer.appendChild(list2);
            }
        };
        
        const showTypingSummaryAndExit = () => {
            isTypingPracticeActive = false;
            document.removeEventListener('keydown', handleTypingKeyPress);
            
            const keyFingering = {
                'q': 'å·¦æ‰‹å°æŒ‡', 'a': 'å·¦æ‰‹å°æŒ‡', 'z': 'å·¦æ‰‹å°æŒ‡',
                'w': 'å·¦æ‰‹æ— åæŒ‡', 's': 'å·¦æ‰‹æ— åæŒ‡', 'x': 'å·¦æ‰‹æ— åæŒ‡',
                'e': 'å·¦æ‰‹ä¸­æŒ‡', 'd': 'å·¦æ‰‹ä¸­æŒ‡', 'c': 'å·¦æ‰‹ä¸­æŒ‡',
                'r': 'å·¦æ‰‹é£ŸæŒ‡', 'f': 'å·¦æ‰‹é£ŸæŒ‡', 'v': 'å·¦æ‰‹é£ŸæŒ‡',
                't': 'å·¦æ‰‹é£ŸæŒ‡', 'g': 'å·¦æ‰‹é£ŸæŒ‡', 'b': 'å·¦æ‰‹é£ŸæŒ‡',
                'y': 'å³æ‰‹é£ŸæŒ‡', 'h': 'å³æ‰‹é£ŸæŒ‡', 'n': 'å³æ‰‹é£ŸæŒ‡',
                'u': 'å³æ‰‹é£ŸæŒ‡', 'j': 'å³æ‰‹é£ŸæŒ‡', 'm': 'å³æ‰‹é£ŸæŒ‡',
                'i': 'å³æ‰‹ä¸­æŒ‡', 'k': 'å³æ‰‹ä¸­æŒ‡',
                'o': 'å³æ‰‹æ— åæŒ‡', 'l': 'å³æ‰‹æ— åæŒ‡',
                'p': 'å³æ‰‹å°æŒ‡'
            };

            const errorRates = [];
            for (const char in typingSessionStats.totalPresses) {
                const total = typingSessionStats.totalPresses[char];
                const errors = typingSessionStats.errors[char] || 0;
                if (total > 0) {
                    errorRates.push({
                        char: char.toUpperCase(),
                        rate: (errors / total) * 100,
                        finger: keyFingering[char] || 'æœªçŸ¥'
                    });
                }
            }

            errorRates.sort((a, b) => b.rate - a.rate);

            let summaryHtml = "<h4>æœ¬æ¬¡æ‰“å­—ç»ƒä¹ æ€»ç»“</h4>";
            const highErrorKeys = errorRates.filter(k => k.rate > 0).slice(0, 3);

            if (highErrorKeys.length > 0) {
                summaryHtml += "<p>ä½ ä¼¼ä¹åœ¨ä»¥ä¸‹å‡ ä¸ªå­—æ¯ä¸Šé‡åˆ°äº†å›°éš¾ï¼š</p><ul>";
                highErrorKeys.forEach(key => {
                    summaryHtml += `<li><strong>å­—æ¯ ${key.char}</strong>: é”™è¯¯ç‡ ${key.rate.toFixed(0)}%ã€‚<br><small>å»ºè®®ï¼šä½¿ç”¨ <strong>${key.finger}</strong> æ¥æŒ‰æ­¤é”®ï¼Œå¤šåŠ ç»ƒä¹ ï¼</small></li>`;
                });
                summaryHtml += "</ul>";
            } else if (Object.keys(typingSessionStats.totalPresses).length > 0) {
                 summaryHtml += "<p>ğŸ‰ é›¶é”™è¯¯ï¼å¤ªæ£’äº†ï¼Œè¯·ç»§ç»­ä¿æŒï¼</p>";
            } else {
                 summaryHtml += "<p>ä½ æ²¡æœ‰å®Œæˆä»»ä½•ä¸€è½®ç»ƒä¹ ï¼Œæ²¡æœ‰æ•°æ®å¯ä¾›åˆ†æã€‚</p>";
            }

            showMessage(summaryHtml, goBackToMainMenu);
        };

        typingBackButton.addEventListener('click', showTypingSummaryAndExit);

        // --- Advanced Typing Logic ---
        const startAdvancedTypingPractice = () => {
            isAdvancedTypingActive = true;
            advancedTypingChars = [];
            advancedTypingCurrentIndex = 0;
            advancedTypingCombo = 0;
            advancedTypingMaxCombo = 0;
            advancedTypingLastCorrectTime = 0;
            advancedTypingTotalTyped = 0;
            advancedTypingTotalErrors = 0;
            
            // Generate initial characters
            for (let i = 0; i < 10; i++) {
                advancedTypingChars.push(alphabet[Math.floor(Math.random() * alphabet.length)]);
            }

            updateAdvancedTypingPrompt();
            advancedTypingFeedback.textContent = 'å¼€å§‹ï¼';
            advancedTypingFeedback.className = '';
            document.addEventListener('keydown', handleAdvancedTypingKeyPress);
            showPage('advanced-typing-section');
        };

        const updateAdvancedTypingPrompt = () => {
            advancedTypingPrompt.innerHTML = '';

            // Determine the starting point for rendering to keep the display concise
            // This will show up to 10 past characters, keeping the total visible under 20.
            const displayStartIndex = Math.max(0, advancedTypingCurrentIndex - 10);
            const charsToDisplay = advancedTypingChars.slice(displayStartIndex);

            charsToDisplay.forEach((char, index) => {
                const originalIndex = index + displayStartIndex;
                const span = document.createElement('span');
                span.textContent = char;

                if (originalIndex < advancedTypingCurrentIndex) {
                    span.className = 'correctly-typed';
                } else if (originalIndex === advancedTypingCurrentIndex) {
                    span.className = 'current-char';
                }
                advancedTypingPrompt.appendChild(span);
            });
        };

        const handleAdvancedTypingKeyPress = (event) => {
            if (!isAdvancedTypingActive || event.key.length > 1 || !/^[a-zA-Z]$/.test(event.key)) return;
            
            event.preventDefault(); // Prevent default browser actions
            const keyPressed = event.key.toLowerCase();
            const correctChar = advancedTypingChars[advancedTypingCurrentIndex];
            const normalFeedback = ['ä¸é”™ï¼', 'å¾ˆå¥½ï¼', 'ç»§ç»­ï¼'];
            const comboFeedback = ['æ¼‚äº®ï¼', 'å¤ªæ£’äº†ï¼', 'æ‰‹é€ŸæƒŠäººï¼'];

            advancedTypingTotalTyped++;

            if (keyPressed === correctChar) {
                const now = performance.now();
                const timeDiff = now - advancedTypingLastCorrectTime;
                
                if (timeDiff < COMBO_THRESHOLD_MS) {
                    advancedTypingCombo++;
                    advancedTypingFeedback.innerHTML = `<span class="combo">${comboFeedback[Math.floor(Math.random() * comboFeedback.length)]} Combo x${advancedTypingCombo}!</span>`;
                } else {
                    advancedTypingCombo = 1;
                    advancedTypingFeedback.textContent = normalFeedback[Math.floor(Math.random() * normalFeedback.length)];
                    advancedTypingFeedback.className = 'correct';
                }
                
                advancedTypingLastCorrectTime = now;
                if (advancedTypingCombo > advancedTypingMaxCombo) {
                    advancedTypingMaxCombo = advancedTypingCombo;
                }

                advancedTypingCurrentIndex++;

                // Add more characters if needed
                if (advancedTypingChars.length - advancedTypingCurrentIndex < 5) {
                    for (let i = 0; i < 5; i++) {
                        advancedTypingChars.push(alphabet[Math.floor(Math.random() * alphabet.length)]);
                    }
                }
                updateAdvancedTypingPrompt();

            } else {
                advancedTypingCombo = 0;
                advancedTypingTotalErrors++;
                advancedTypingFeedback.textContent = `å“å‘€ï¼Œé”™äº†ï¼åº”è¯¥æ˜¯ '${correctChar.toUpperCase()}'`;
                advancedTypingFeedback.className = 'incorrect';
                playErrorSound();
            }
        };
        
        const showAdvancedTypingSummaryAndExit = () => {
            isAdvancedTypingActive = false;
            document.removeEventListener('keydown', handleAdvancedTypingKeyPress);

            let summaryHtml = "<h4>è¿›é˜¶ç»ƒä¹ æ€»ç»“</h4>";
            if (advancedTypingTotalTyped > 0) {
                 const accuracy = ((advancedTypingTotalTyped - advancedTypingTotalErrors) / advancedTypingTotalTyped * 100).toFixed(1);
                 summaryHtml += `<p>æœ¬æ¬¡ç»ƒä¹ ä½ ä¸€å…±è¾“å…¥äº† <strong>${advancedTypingTotalTyped}</strong> ä¸ªå­—æ¯ã€‚</p>
                                 <p>æœ€é•¿è¿å‡» (Max Combo): <strong>${advancedTypingMaxCombo}</strong></p>
                                 <p>å‡†ç¡®ç‡: <strong>${accuracy}%</strong></p>`;
            } else {
                 summaryHtml += "<p>ä½ æ²¡æœ‰è¿›è¡Œä»»ä½•è¾“å…¥ã€‚</p>";
            }
            
            showMessage(summaryHtml, goBackToMainMenu);
        };
        
        advancedTypingBackButton.addEventListener('click', showAdvancedTypingSummaryAndExit);


        const goBackToMainMenu = () => {
            showPage('setup-section');
            words = [];
            originalWords = [];
            wordInput.value = '';
            uploadStatus.textContent = 'æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶';
            fileUpload.value = '';
            selectedFile = null;
            startButton.disabled = true;
            uploadConfirmButton.disabled = true;
            newWordsRadio.checked = true;
            audioCache.clear();
            exampleSentenceCache.clear();
            isTypingWithWordsMode = false;
            loadPracticeSessionsFromFirestore();
            updatePracticeModeDisplay();
        };

        restartButton.addEventListener('click', goBackToMainMenu);

        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        };

        const updateStartButtonState = () => {
            let canStart = false;
            const selectedMode = document.querySelector('input[name="practice-mode"]:checked').value;
            switch(selectedMode) {
                case 'new-words':
                    canStart = wordInput.value.trim() !== '' || (selectedFile && !uploadConfirmButton.disabled);
                    break;
                case 'wrong-words':
                    canStart = inlineWrongWordsSelection.querySelectorAll('input[type="checkbox"]:checked').length > 0;
                    break;
                case 'word-library':
                    canStart = words.length > 0;
                    break;
                case 'mc-quiz':
                    const mcSource = document.querySelector('input[name="mc-source"]:checked').value;
                    canStart = (mcSource === 'random') ? (parseInt(randomWordCountInput.value) > 0 && allWordsFromLibrary.length > 0) : (words.length > 0);
                    break;
                case 'typing-practice':
                case 'advanced-typing': // Add condition for new mode
                    canStart = true;
                    break;
            }
            startButton.disabled = !canStart;
        };

        const updatePracticeModeDisplay = () => {
            document.querySelectorAll('.mode-setup-section').forEach(el => el.style.display = 'none');
            const selectedMode = document.querySelector('input[name="practice-mode"]:checked').value;
            commonSettings.style.display = 'block';
            switch(selectedMode) {
                case 'new-words': newWordsInputArea.style.display = 'flex'; break;
                case 'wrong-words': if (persistentWrongWords.length > 0) { inlineWrongWordsSelection.style.display = 'flex'; showInlineWrongWordsSelection(); } break;
                case 'word-library': wordLibrarySelectionArea.style.display = 'flex'; updateSelectedLibraryDisplay(); break;
                case 'mc-quiz': multipleChoiceSetupArea.style.display = 'flex'; updateMcSourceDisplay(); break;
                case 'typing-practice': simpleModeArea.style.display = 'flex'; commonSettings.style.display = 'none'; break;
                case 'advanced-typing': advancedTypingSetupArea.style.display = 'flex'; commonSettings.style.display = 'none'; break;
            }
            updateStartButtonState();
        };
        
        const updateMcSourceDisplay = () => {
            const mcSource = document.querySelector('input[name="mc-source"]:checked').value;
            mcRandomOptions.style.display = (mcSource === 'random') ? 'flex' : 'none';
            mcManualOptions.style.display = (mcSource === 'manual') ? 'block' : 'none';
            updateStartButtonState();
        };

        // --- Inline Wrong Words Selection Logic ---
        const showInlineWrongWordsSelection = () => {
            if (!allPracticeSessions || allPracticeSessions.length === 0) {
                inlineWrongWordsSessionsList.innerHTML = '<p style="text-align: center; color: #777;">æš‚æ— é”™é¢˜è®°å½•ã€‚</p>';
                return;
            }
            
            inlineWrongWordsSessionsList.innerHTML = '';
            allPracticeSessions.forEach(session => {
                const wrongWordsInSession = session.sessionWords?.filter(w => !w.wasCorrect) || [];
                if (wrongWordsInSession.length === 0) return;

                const sessionItem = document.createElement('div');
                sessionItem.className = 'session-item';
                const sessionHeader = document.createElement('div');
                sessionHeader.className = 'session-header';
                
                const sessionDate = session.endTime.toDate ? session.endTime.toDate().toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : 'æœªçŸ¥æ—¥æœŸ';
                const accuracyText = session.accuracy !== undefined ? `${(session.accuracy * 100).toFixed(0)}%` : 'N/A';
                const profileNameText = session.profileName ? ` [${session.profileName}]` : '';

                sessionHeader.innerHTML = `
                    <input type="checkbox" value="${session.id}">
                    <div class="session-info">
                        <strong>${sessionDate}</strong>${profileNameText} (${wrongWordsInSession.length} ä¸ªé”™è¯, æ­£ç¡®ç‡ ${accuracyText})
                        <span class="session-mode">${session.practiceMode || 'æœªçŸ¥æ¨¡å¼'}</span>
                    </div>
                    <span class="toggle-icon">â–¶</span>`;
                sessionItem.appendChild(sessionHeader);

                const wordsList = document.createElement('ul');
                wordsList.className = 'session-words-list';
                session.sessionWords.forEach(word => {
                    const statusClass = word.wasCorrect ? 'correct' : 'incorrect';
                    const statusSymbol = word.wasCorrect ? 'âœ”' : 'âŒ';
                    wordsList.innerHTML += `<li><span class="${statusClass}">${statusSymbol} ${word.english}: ${word.chinese}</span></li>`;
                });
                sessionItem.appendChild(wordsList);
                inlineWrongWordsSessionsList.appendChild(sessionItem);

                sessionHeader.addEventListener('click', (e) => {
                    if (e.target.type === 'checkbox') return;
                    wordsList.classList.toggle('show');
                    sessionHeader.querySelector('.toggle-icon').classList.toggle('expanded');
                });
            });
            updateStartButtonState();
        };

        inlineWrongWordsSelection.addEventListener('change', (e) => { if (e.target.type === 'checkbox') updateStartButtonState(); });

        document.getElementById('clear-wrong-words-button').addEventListener('click', () => {
            showMessage(`è¯·è¾“å…¥ç¡®è®¤ç ä»¥æ¸…é™¤æ‰€æœ‰é”™é¢˜è®°å½•ã€‚<br>æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼<br><br><input type="text" id="confirm-code-input" placeholder="è¾“å…¥ç¡®è®¤ç "><br><button id="confirm-clear-wrong-words" class="secondary" style="width: auto; margin-right: 10px;">ç¡®è®¤æ¸…é™¤</button><button id="cancel-clear-wrong-words" style="width: auto;">å–æ¶ˆ</button>`);
            document.getElementById('confirm-clear-wrong-words').onclick = async () => {
                if (document.getElementById('confirm-code-input').value === '1234') {
                    messageDialog.style.display = 'none';
                    showLoader("æ­£åœ¨æ¸…é™¤æ‰€æœ‰è®°å½•...");
                    try {
                        const sessionsCollectionPath = `${USER_SESSIONS_COLLECTION_BASE}${userId}/practiceSessions`;
                        const querySnapshot = await getDocs(query(collection(db, sessionsCollectionPath)));
                        const batch = writeBatch(db);
                        querySnapshot.forEach(doc => batch.delete(doc.ref));
                        await batch.commit();
                        await loadPracticeSessionsFromFirestore();
                        showMessage('æ‰€æœ‰é”™é¢˜è®°å½•å·²æ¸…é™¤ã€‚');
                        newWordsRadio.checked = true;
                        updatePracticeModeDisplay();
                    } catch (error) {
                        console.error("æ¸…é™¤é”™é¢˜è®°å½•æ—¶å‡ºé”™: ", error);
                        showMessage("æ¸…é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–é‡è¯•ã€‚");
                    } finally { hideLoader(); }
                } else { showMessage('ç¡®è®¤ç ä¸æ­£ç¡®ï¼Œæ¸…é™¤æ“ä½œå·²å–æ¶ˆã€‚'); }
            };
            document.getElementById('cancel-clear-wrong-words').onclick = () => { messageDialog.style.display = 'none'; };
        });

        // --- Setup Section Logic ---
        wordInput.addEventListener('input', () => {
            if(wordInput.value.trim() !== '') {
                uploadStatus.textContent = 'å·²è¾“å…¥æ–‡æœ¬ï¼Œå°†ä¼˜å…ˆä½¿ç”¨æ–‡æœ¬å†…å®¹ã€‚';
                uploadConfirmButton.disabled = true;
                selectedFile = null;
                fileUpload.value = '';
            } else if (selectedFile) {
                 uploadStatus.textContent = `å·²é€‰æ‹©: ${selectedFile.name}`;
                 uploadConfirmButton.disabled = false;
            } else {
                 uploadStatus.textContent = 'æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶';
                 uploadConfirmButton.disabled = true;
            }
            updateStartButtonState();
        });

        selectFileButton.addEventListener('click', () => fileUpload.click());

        fileUpload.addEventListener('change', (event) => {
            selectedFile = event.target.files[0];
            if (!selectedFile) {
                uploadStatus.textContent = 'æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶';
                uploadConfirmButton.disabled = true;
            } else {
                uploadStatus.textContent = `å·²é€‰æ‹©: ${selectedFile.name}`;
                uploadConfirmButton.disabled = false;
                wordInput.value = '';
            }
            updateStartButtonState();
        });

        uploadConfirmButton.addEventListener('click', async () => {
            if (!selectedFile) return;
            try {
                showLoader('æ­£åœ¨å¤„ç†æ–‡ä»¶...');
                const base64Data = await fileToBase64(selectedFile);
                const mimeType = selectedFile.type || getMimeType(selectedFile.name);
                showLoader('æ­£åœ¨æå–æ–‡ä»¶å†…å®¹...');
                const extractedText = await extractTextFromFile(base64Data, mimeType);
                wordInput.value = extractedText;
                uploadStatus.textContent = `æ–‡ä»¶å†…å®¹å·²æå–ï¼Œè¯·ç‚¹å‡»â€œå‡†å¤‡å¼€å§‹â€ã€‚`;
                selectedFile = null; 
                fileUpload.value = '';
                uploadConfirmButton.disabled = true;
                updateStartButtonState();
            } catch (error) {
                console.error("å¤„ç†æ–‡ä»¶å¤±è´¥:", error);
                showMessage(`å¤„ç†æ–‡ä»¶å¤±è´¥: ${error.message}`);
                uploadStatus.textContent = 'å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚';
            } finally { hideLoader(); }
        });

        const getMimeType = (filename) => {
            const extension = filename.split('.').pop().toLowerCase();
            const mimeTypes = { 'jpg': 'image/jpeg', 'png': 'image/png', 'txt': 'text/plain', 'pdf': 'application/pdf' };
            return mimeTypes[extension] || 'application/octet-stream';
        };

        document.querySelectorAll('input[name="practice-mode"]').forEach(radio => radio.addEventListener('change', updatePracticeModeDisplay));
        mcSourceRadios.forEach(radio => radio.addEventListener('change', updateMcSourceDisplay));
        randomWordCountInput.addEventListener('input', updateStartButtonState);
        selectMcWordsButton.addEventListener('click', () => openWordLibraryModal('select-mc'));
        googleTtsCheckbox.addEventListener('change', () => { googleTranslateTtsEnabled = googleTtsCheckbox.checked; });
        showExampleSentenceCheckbox.addEventListener('change', () => { showExampleSentenceEnabled = showExampleSentenceCheckbox.checked; });

        startButton.addEventListener('click', async () => {
            if (!currentUserProfile) {
                showMessage("å¼€å§‹ç»ƒä¹ å‰ï¼Œè¯·å…ˆé€‰æ‹©æˆ–åˆ›å»ºä¸€ä¸ªç»ƒä¹ ç”¨æˆ·åã€‚");
                return;
            }
            let tempWords = [];
            const selectedMode = document.querySelector('input[name="practice-mode"]:checked').value;
            
            if (selectedMode === 'typing-practice') { startTypingPractice(); return; }
            if (selectedMode === 'advanced-typing') { startAdvancedTypingPractice(); return; }


            if (selectedMode === 'wrong-words') {
                const selectedSessionIds = Array.from(inlineWrongWordsSelection.querySelectorAll('input:checked')).map(cb => cb.value);
                if (selectedSessionIds.length === 0) { showMessage('è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªé”™é¢˜ç»ƒä¹ ä¼šè¯ã€‚'); return; }
                let wordsToPracticeMap = new Map();
                allPracticeSessions.forEach(session => {
                    if (selectedSessionIds.includes(session.id)) {
                        (session.sessionWords || []).filter(w => !w.wasCorrect).forEach(word => {
                            wordsToPracticeMap.set(word.english, { english: word.english, chinese: word.chinese });
                        });
                    }
                });
                tempWords = Array.from(wordsToPracticeMap.values());
            } else if (selectedMode === 'word-library' || (selectedMode === 'mc-quiz' && document.querySelector('input[name="mc-source"]:checked').value === 'manual')) {
                if (words.length === 0) { showMessage('è¯·ä»å•è¯åº“ä¸­é€‰æ‹©è‡³å°‘ä¸€ä¸ªå•è¯ã€‚'); return; }
                tempWords = [...words];
            } else if (selectedMode === 'mc-quiz' && document.querySelector('input[name="mc-source"]:checked').value === 'random') {
                const count = parseInt(randomWordCountInput.value);
                if (isNaN(count) || count <= 0) { showMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„éšæœºå•è¯æ•°é‡ã€‚'); return; }
                if (count > allWordsFromLibrary.length) { showMessage(`å•è¯åº“ä¸­åªæœ‰ ${allWordsFromLibrary.length} ä¸ªå•è¯ã€‚`); return; }
                shuffleArray(allWordsFromLibrary);
                tempWords = allWordsFromLibrary.slice(0, count);
            } else { // new-words
                const parsedWords = parseWordInput(wordInput.value);
                if (parsedWords.length === 0) { showMessage('è¯·è¾“å…¥å•è¯ï¼'); return; }
                try {
                    showLoader('æ­£åœ¨ç¿»è¯‘å’ŒéªŒè¯å•è¯...');
                    tempWords = await processWordsForQuiz(parsedWords);
                } catch (error) {
                     console.error("å¤„ç†å•è¯æ—¶å‘ç”Ÿé”™è¯¯:", error);
                     showMessage(`å¤„ç†å•è¯æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
                     return;
                } finally { hideLoader(); }
            }

            if (tempWords.length > 0) {
                words = [...tempWords];
                originalWords = [...tempWords]; // Keep a backup of the original list for repetitions
                if (selectedMode === 'mc-quiz') {
                    await startMcQuiz();
                } else {
                    modeSelectionWordCount.textContent = words.length;
                    showPage('mode-selection-section');
                    // Ensure the repetition setup is hidden initially
                    modeSelectionSection.querySelector('.button-group').style.display = 'flex';
                    typingRepetitionSetup.style.display = 'none';
                }
            } else {
                showMessage('æœªèƒ½æˆåŠŸå¤„ç†æˆ–é€‰ä¸­å•è¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥æˆ–ç½‘ç»œã€‚');
            }
        });

        modeSelectFlashcard.addEventListener('click', startFlashcards);
        modeSelectPractice.addEventListener('click', () => {
            isTypingWithWordsMode = false;
            words = [...originalWords]; // Ensure we start with the original list
            startQuiz();
        });
        modeSelectBack.addEventListener('click', () => {
            showPage('setup-section');
            if (!wordLibraryRadio.checked) {
                words = [];
                originalWords = [];
            }
            updateStartButtonState();
            modeSelectionSection.querySelector('.button-group').style.display = 'flex';
            typingRepetitionSetup.style.display = 'none';
        });

        // --- NEW: Event listeners for "Typing with Words" feature ---
        modeSelectTypingWithWords.addEventListener('click', () => {
            modeSelectionSection.querySelector('.button-group').style.display = 'none';
            typingRepetitionSetup.style.display = 'block';
        });

        cancelTypingWithWordsSetup.addEventListener('click', () => {
            modeSelectionSection.querySelector('.button-group').style.display = 'flex';
            typingRepetitionSetup.style.display = 'none';
        });

        startTypingWithWordsPractice.addEventListener('click', () => {
            let repetitionCount = 1;
            const selectedRadio = document.querySelector('input[name="repetition-count"]:checked').value;
            if (selectedRadio === 'custom') {
                repetitionCount = parseInt(customRepetitionInput.value, 10) || 1;
            } else {
                repetitionCount = parseInt(selectedRadio, 10);
            }

            if (repetitionCount < 1) repetitionCount = 1;

            let repeatedWords = [];
            originalWords.forEach(word => {
                for (let i = 0; i < repetitionCount; i++) {
                    repeatedWords.push({ ...word });
                }
            });
            words = repeatedWords; // Overwrite the global words array for this quiz session

            isTypingWithWordsMode = true;
            startQuiz();
        });

        repetitionRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                const isCustom = document.querySelector('input[name="repetition-count"]:checked').value === 'custom';
                customRepetitionInput.disabled = !isCustom;
                if(isCustom) customRepetitionInput.focus();
            });
        });
        customRepetitionInput.disabled = document.querySelector('input[name="repetition-count"]:checked').value !== 'custom';
        customRepetitionInput.addEventListener('input', () => {
             document.querySelector('input[name="repetition-count"][value="custom"]').checked = true;
             customRepetitionInput.disabled = false;
        });

        // --- Word Library Management Logic ---
        const updateSelectedLibraryDisplay = () => {
            if (wordLibraryRadio.checked) {
                selectedLibraryDisplay.innerHTML = words.length > 0 ? `å·²é€‰æ‹© <span>${words.length}</span> ä¸ªå•è¯` : 'æœªé€‰æ‹©å•è¯';
            }
            if (mcQuizRadio.checked) {
                mcSelectedDisplay.innerHTML = words.length > 0 ? `å·²é€‰æ‹© <span>${words.length}</span> ä¸ªå•è¯` : 'æœªé€‰æ‹©å•è¯';
            }
        };

        const openWordLibraryModal = async (purpose = 'manage') => {
             if (!isAuthReady) {
                showMessage("Firebase æœªå‡†å¤‡å¥½ï¼Œæ— æ³•ä½¿ç”¨å•è¯åº“åŠŸèƒ½ã€‚è¯·æ£€æŸ¥ç½‘ç»œã€‚");
                return;
            }
            
            wordLibraryModal.dataset.purpose = purpose; // 'manage', 'select-spell', 'select-mc'

            if (purpose === 'manage') {
                modalTitle.textContent = 'ç®¡ç†å•è¯åº“';
                manageView.style.display = 'block';
                selectView.style.display = 'none';
                loadLibrariesForManageMode();
                subsetManagementSection.style.display = 'none';
                wordsManagementSection.style.display = 'none';
                subsetsList.innerHTML = '<p style="text-align: center; color: #777;">è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå•è¯åº“ã€‚</p>';
                subsetWordsInput.value = '';
            } else {
                modalTitle.textContent = 'é€‰æ‹©å•è¯è¿›è¡Œç»ƒä¹ ';
                manageView.style.display = 'none';
                selectView.style.display = 'block';
                await buildPracticeSelectionTree();
            }
            wordLibraryModal.style.display = 'flex';
        };
        
        openManageModalButton.addEventListener('click', () => openWordLibraryModal('manage'));
        selectLibraryForPracticeButton.addEventListener('click', () => openWordLibraryModal('select-spell'));


        modalCloseButton.addEventListener('click', () => {
            wordLibraryModal.style.display = 'none';
            updateSelectedLibraryDisplay();
            updateStartButtonState();
        });

        createLibraryButton.addEventListener('click', async () => {
            const name = newLibraryNameInput.value.trim();
            if (!name) { showMessage('è¯·è¾“å…¥å•è¯åº“åç§°ã€‚'); return; }
            if (!userId) { showMessage('ç”¨æˆ·æœªè®¤è¯ï¼Œæ— æ³•åˆ›å»ºå•è¯åº“ã€‚'); return; }
            showLoader('æ­£åœ¨åˆ›å»ºå•è¯åº“...');
            try {
                const librariesRef = collection(db, PUBLIC_LIBRARIES_COLLECTION);
                await addDoc(librariesRef, { name: name, userId: userId });
                newLibraryNameInput.value = '';
                await loadLibrariesForManageMode();
                showMessage(`å•è¯åº“ "${name}" åˆ›å»ºæˆåŠŸï¼`);
            } catch (error) {
                console.error("åˆ›å»ºå•è¯åº“å¤±è´¥:", error);
                showMessage("åˆ›å»ºå•è¯åº“å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
            } finally {
                hideLoader();
            }
        });

        const loadLibrariesForManageMode = async () => {
            if (!isAuthReady || !userId) {
                librariesList.innerHTML = '<p style="text-align: center; color: #777;">è¯·ç™»å½•åæŸ¥çœ‹å•è¯åº“ã€‚</p>';
                return;
            }
            showLoader('æ­£åœ¨åŠ è½½å•è¯åº“...');
            try {
                const librariesRef = collection(db, PUBLIC_LIBRARIES_COLLECTION);
                const querySnapshot = await getDocs(librariesRef);
                allLibraries = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                librariesList.innerHTML = '';
                if (allLibraries.length === 0) {
                    librariesList.innerHTML = '<p style="text-align: center; color: #777;">æš‚æ— å•è¯åº“ã€‚</p>';
                } else {
                    allLibraries.forEach(library => {
                        const div = document.createElement('div');
                        div.classList.add('modal-list-item', 'library-item');
                        div.dataset.id = library.id;
                        div.dataset.name = library.name;
                        
                        const ownerText = library.userId === userId ? ' (æˆ‘åˆ›å»ºçš„)' : '';
                        div.innerHTML = `<span>${library.name}${ownerText}</span>
                                        <div>
                                            <button data-id="${library.id}" data-name="${library.name}" class="rename-library-button secondary">é‡å‘½å</button>
                                            <button data-id="${library.id}" class="delete-library-button secondary">åˆ é™¤</button>
                                        </div>`;
                        librariesList.appendChild(div);

                        div.addEventListener('click', async (e) => {
                            if (e.target.tagName === 'BUTTON') return;
                            librariesList.querySelectorAll('.modal-list-item').forEach(item => item.classList.remove('selected'));
                            subsetsList.innerHTML = '<p style="text-align: center; color: #777;">è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå•è¯åº“ã€‚</p>';
                            subsetWordsInput.value = '';
                            selectedSubsetId = null;
                            selectedSubsetName = null;
                            wordsManagementSection.style.display = 'none';

                            div.classList.add('selected');
                            selectedLibraryId = library.id;
                            selectedLibraryName = library.name;
                            currentLibraryNameSpan.textContent = selectedLibraryName;
                            subsetManagementSection.style.display = 'flex';
                            await loadSubsetsForManageMode(selectedLibraryId);
                        });
                    });
                }
            } catch (error) {
                console.error("åŠ è½½å•è¯åº“å¤±è´¥:", error);
                showMessage("åŠ è½½å•è¯åº“å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚");
            } finally {
                hideLoader();
            }
        };

        librariesList.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('delete-library-button')) {
                const libraryIdToDelete = target.dataset.id;
                const libraryToDelete = allLibraries.find(lib => lib.id === libraryIdToDelete);

                showMessage(`è¯·è¾“å…¥ç¡®è®¤ç ä»¥åˆ é™¤å•è¯åº“ "<strong>${libraryToDelete.name}</strong>"ã€‚<br>æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼<br><br><input type="text" id="confirm-code-input" placeholder="è¾“å…¥ç¡®è®¤ç "><br><button id="confirm-delete-library" class="secondary" style="width: auto; margin-right: 10px;">ç¡®è®¤åˆ é™¤</button><button id="cancel-delete-library" style="width: auto;">å–æ¶ˆ</button>`);

                document.getElementById('confirm-delete-library').onclick = async () => {
                    const code = document.getElementById('confirm-code-input').value;
                    if (code === '1234') {
                        messageDialog.style.display = 'none';
                        showLoader('æ­£åœ¨åˆ é™¤å•è¯åº“...');
                        try {
                            const batch = writeBatch(db);
                            const subsetsToDeleteSnapshot = await getDocs(query(collection(db, PUBLIC_SUBSETS_COLLECTION), where("libraryId", "==", libraryIdToDelete)));
                            for (const subsetDoc of subsetsToDeleteSnapshot.docs) {
                                const wordsSnapshot = await getDocs(query(collection(db, PUBLIC_WORDS_COLLECTION), where("subsetId", "==", subsetDoc.id)));
                                wordsSnapshot.forEach(wordDoc => batch.delete(doc.ref));
                                batch.delete(subsetDoc.ref);
                            }
                            batch.delete(doc(db, PUBLIC_LIBRARIES_COLLECTION, libraryIdToDelete));
                            await batch.commit();

                            if (selectedLibraryId === libraryIdToDelete) {
                                selectedLibraryId = null; selectedLibraryName = null;
                                selectedSubsetId = null; selectedSubsetName = null;
                                subsetManagementSection.style.display = 'none';
                                wordsManagementSection.style.display = 'none';
                            }
                            await loadLibrariesForManageMode();
                            showMessage('å•è¯åº“å·²åˆ é™¤ã€‚');
                        } catch (error) {
                            console.error("åˆ é™¤å•è¯åº“å¤±è´¥:", error);
                            showMessage("åˆ é™¤å•è¯åº“å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
                        } finally {
                            hideLoader();
                        }
                    } else {
                        showMessage('ç¡®è®¤ç ä¸æ­£ç¡®ï¼Œåˆ é™¤æ“ä½œå·²å–æ¶ˆã€‚');
                    }
                };
                document.getElementById('cancel-delete-library').onclick = () => {
                    messageDialog.style.display = 'none';
                };
            }
            if (target.classList.contains('rename-library-button')) {
                const libraryId = target.dataset.id;
                const libraryName = target.dataset.name;
                const library = allLibraries.find(lib => lib.id === libraryId);

                const promptHtml = (library.userId === userId) ?
                    `è¯·è¾“å…¥ "${libraryName}" çš„æ–°åç§°ï¼š<br><input type="text" id="rename-input" value="${libraryName}">` :
                    `è¯·è¾“å…¥ç¡®è®¤ç ä»¥é‡å‘½åå•è¯åº“ "<strong>${libraryName}</strong>"ï¼š<br><input type="text" id="confirm-code-input" placeholder="è¾“å…¥ç¡®è®¤ç "><br><input type="text" id="rename-input" value="${libraryName}" placeholder="æ–°åç§°">`;

                showMessage(`${promptHtml}<br><br><button id="confirm-rename" class="secondary" style="width: auto; margin-right: 10px;">ç¡®è®¤</button><button id="cancel-rename" style="width: auto;">å–æ¶ˆ</button>`);
                
                document.getElementById('confirm-rename').onclick = async () => {
                    const newName = document.getElementById('rename-input').value.trim();
                    const codeInput = document.getElementById('confirm-code-input');
                    if (codeInput && codeInput.value !== '1234') { showMessage('ç¡®è®¤ç ä¸æ­£ç¡®ã€‚'); return; }
                    if (!newName) { showMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„å•è¯åº“åç§°ã€‚'); return; }
                    
                    showLoader('æ­£åœ¨é‡å‘½å...');
                    try {
                        await setDoc(doc(db, PUBLIC_LIBRARIES_COLLECTION, libraryId), { name: newName }, { merge: true });
                        if (selectedLibraryId === libraryId) { selectedLibraryName = newName; }
                        await loadLibrariesForManageMode();
                        showMessage('å•è¯åº“åç§°å·²æ›´æ–°ã€‚');
                    } catch (error) {
                        console.error("é‡å‘½åå¤±è´¥:", error);
                        showMessage("é‡å‘½åå¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
                    } finally { hideLoader(); }
                };
                document.getElementById('cancel-rename').onclick = () => { messageDialog.style.display = 'none'; };
            } 
        });

        createSubsetButton.addEventListener('click', async () => {
            const name = newSubsetNameInput.value.trim();
            if (!name) { showMessage('è¯·è¾“å…¥å­é›†åç§°ã€‚'); return; }
            if (!selectedLibraryId) { showMessage('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå•è¯åº“ã€‚'); return; }
            if (!userId) { showMessage('ç”¨æˆ·æœªè®¤è¯ï¼Œæ— æ³•åˆ›å»ºå­é›†ã€‚'); return; }
            showLoader('æ­£åœ¨åˆ›å»ºå­é›†...');
            try {
                const subsetsRef = collection(db, PUBLIC_SUBSETS_COLLECTION);
                await addDoc(subsetsRef, { name: name, libraryId: selectedLibraryId, userId: userId });
                newSubsetNameInput.value = '';
                await loadSubsetsForManageMode(selectedLibraryId);
                showMessage(`å­é›† "${name}" åˆ›å»ºæˆåŠŸï¼`);
            } catch (error) {
                console.error("åˆ›å»ºå­é›†å¤±è´¥:", error);
                showMessage("åˆ›å»ºå­é›†å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
            } finally {
                hideLoader();
            }
        });

        const loadSubsetsForManageMode = async (libraryId) => {
            if (!isAuthReady || !userId || !libraryId) {
                subsetsList.innerHTML = '<p style="text-align: center; color: #777;">è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå•è¯åº“ã€‚</p>';
                return;
            }
            showLoader('æ­£åœ¨åŠ è½½å­é›†...');
            try {
                const subsetsRef = collection(db, PUBLIC_SUBSETS_COLLECTION);
                const q = query(subsetsRef, where("libraryId", "==", libraryId));
                const querySnapshot = await getDocs(q);
                const loadedSubsets = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                const wordsRef = collection(db, PUBLIC_WORDS_COLLECTION);
                const qWords = query(wordsRef, where("libraryId", "==", libraryId));
                const wordsSnapshot = await getDocs(qWords);
                allWordsInCurrentLibrary = wordsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                subsetsList.innerHTML = '';
                if (loadedSubsets.length === 0) {
                    subsetsList.innerHTML = '<p style="text-align: center; color: #777;">æš‚æ— å­é›†ã€‚</p>';
                } else {
                    loadedSubsets.forEach(subset => {
                        const div = document.createElement('div');
                        div.classList.add('modal-list-item');
                        if (selectedSubsetId === subset.id) div.classList.add('selected');
                        
                        const wordCount = allWordsInCurrentLibrary.filter(word => word.subsetId === subset.id).length;
                        const ownerText = subset.userId === userId ? ' (æˆ‘åˆ›å»ºçš„)' : '';
                        
                        div.innerHTML = `<span>${subset.name} (${wordCount} è¯)${ownerText}</span>
                                        <div>
                                            <button data-id="${subset.id}" data-name="${subset.name}" class="select-subset-button secondary">é€‰æ‹©</button>
                                            <button data-id="${subset.id}" data-name="${subset.name}" class="rename-subset-button secondary" >é‡å‘½å</button>
                                            <button data-id="${subset.id}" class="delete-subset-button secondary" >åˆ é™¤</button>
                                        </div>`;
                        subsetsList.appendChild(div);
                    });
                }
            } catch (error) {
                console.error("åŠ è½½å­é›†å¤±è´¥:", error);
                showMessage("åŠ è½½å­é›†å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚");
            } finally {
                hideLoader();
            }
        };


        subsetsList.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('select-subset-button')) {
                selectedSubsetId = target.dataset.id;
                selectedSubsetName = target.dataset.name;
                currentSubsetNameSpan.textContent = selectedSubsetName;
                
                wordsManagementSection.style.display = 'flex';
                showLoader('æ­£åœ¨åŠ è½½å­é›†å•è¯...');
                try {
                    const loadedWords = await loadWordsFromSubset(selectedSubsetId);
					subsetWordsInput.value = loadedWords.map(w => `${w.english}#${w.chinese}`).join('\n');
                } catch (error) {
                    console.error("åŠ è½½å­é›†å•è¯å¤±è´¥:", error);
                    showMessage("åŠ è½½å­é›†å•è¯å¤±è´¥ã€‚");
                } finally {
                    hideLoader();
                }
                subsetsList.querySelectorAll('.modal-list-item').forEach(item => item.classList.remove('selected'));
                target.closest('.modal-list-item').classList.add('selected');

            } else if (target.classList.contains('delete-subset-button')) {
                const subsetIdToDelete = target.dataset.id;
                const subsetToDelete = allSubsets.find(sub => sub.id === subsetIdToDelete);
                if (subsetToDelete && subsetToDelete.userId !== userId) {
                    showMessage('æ‚¨æ— æƒåˆ é™¤æ­¤å­é›†ã€‚');
                    return;
                }

                showMessage(`ç¡®å®šè¦åˆ é™¤å­é›† "<strong>${subsetToDelete.name}</strong>" åŠå…¶æ‰€æœ‰å•è¯å—ï¼Ÿ<br>æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼<br><br><button id="confirm-delete-subset" class="secondary" style="width: auto; margin-right: 10px;">ç¡®è®¤åˆ é™¤</button><button id="cancel-delete-subset" style="width: auto;">å–æ¶ˆ</button>`);
                
                document.getElementById('confirm-delete-subset').onclick = async () => {
                    messageDialog.style.display = 'none';
                    showLoader('æ­£åœ¨åˆ é™¤å­é›†...');
                    try {
                        const batch = writeBatch(db);
                        const wordsSnapshot = await getDocs(query(collection(db, PUBLIC_WORDS_COLLECTION), where("subsetId", "==", subsetIdToDelete)));
                        wordsSnapshot.forEach(doc => batch.delete(doc.ref));
                        batch.delete(doc(db, PUBLIC_SUBSETS_COLLECTION, subsetIdToDelete));
                        await batch.commit();

                        if (selectedSubsetId === subsetIdToDelete) {
                            selectedSubsetId = null; selectedSubsetName = null;
                            wordsManagementSection.style.display = 'none';
                            subsetWordsInput.value = '';
                        }
                        await loadSubsetsForManageMode(selectedLibraryId);
                        showMessage('å­é›†å·²åˆ é™¤ã€‚');
                    } catch (error) {
                        console.error("åˆ é™¤å­é›†å¤±è´¥:", error);
                        showMessage("åˆ é™¤å­é›†å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
                    } finally {
                        hideLoader();
                    }
                };
                document.getElementById('cancel-delete-subset').onclick = () => { messageDialog.style.display = 'none'; };
            }
            if (target.classList.contains('rename-subset-button')) {
                // Similar rename logic as for libraries
            }
        });

        let selectedSubsetFile = null;
        subsetFileUpload.addEventListener('change', (event) => {
            selectedSubsetFile = event.target.files[0];
            if (!selectedSubsetFile) {
                subsetUploadStatus.textContent = 'æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶';
                uploadSubsetConfirmButton.disabled = true;
                return;
            }
            subsetUploadStatus.textContent = `å·²é€‰æ‹©: ${selectedSubsetFile.name}`;
            uploadSubsetConfirmButton.disabled = false;
        });

        selectSubsetFileButton.addEventListener('click', () => {
            subsetFileUpload.click();
        });

        uploadSubsetConfirmButton.addEventListener('click', async () => {
            if (!selectedSubsetId) { showMessage('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå­é›†æ¥å¯¼å…¥å•è¯ã€‚'); return; }
            if (!selectedSubsetFile) { showMessage('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ã€‚'); return; }

            showLoader('æ­£åœ¨å¤„ç†æ–‡ä»¶...');
            try {
                const base64Data = await fileToBase64(selectedSubsetFile);
                const mimeType = selectedSubsetFile.type || getMimeType(selectedSubsetFile.name);

                const extractedText = await extractTextFromFile(base64Data, mimeType);
                let importedWords = await processWordsForQuiz(parseWordInput(extractedText));

                const existingWords = new Set(subsetWordsInput.value.split('\n').map(line => line.split('#')[0].trim().toLowerCase()).filter(Boolean));
                const newWordsToAppend = importedWords.filter(w => !existingWords.has(w.english.toLowerCase()));

                if (newWordsToAppend.length > 0) {
					const newContentLines = newWordsToAppend.map(w => `${w.english}#${w.chinese || ''}`);
                    subsetWordsInput.value = subsetWordsInput.value.trim() ? `${subsetWordsInput.value.trim()}\n${newContentLines.join('\n')}` : newContentLines.join('\n');
                    subsetUploadStatus.textContent = `æˆåŠŸå¯¼å…¥ ${newWordsToAppend.length} ä¸ªæ–°å•è¯ã€‚è¯·ç‚¹å‡»â€œä¿å­˜â€ã€‚`;
                } else {
                    subsetUploadStatus.textContent = `å¯¼å…¥å®Œæˆï¼Œæ²¡æœ‰å‘ç°æ–°å•è¯ã€‚`;
                }
            } catch (error) {
                console.error("å¯¼å…¥æ–‡ä»¶å¤±è´¥:", error);
                showMessage(`å¯¼å…¥æ–‡ä»¶å¤±è´¥: ${error.message}`);
                subsetUploadStatus.textContent = 'å¯¼å…¥å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚';
            } finally {
                hideLoader();
                selectedSubsetFile = null;
                subsetFileUpload.value = '';
                uploadSubsetConfirmButton.disabled = true;
            }
        });


        saveSubsetWordsButton.addEventListener('click', async () => {
            if (!selectedSubsetId) { showMessage('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå­é›†ã€‚'); return; }
            const rawWordsInput = subsetWordsInput.value.trim();
            saveSubsetWordsButton.disabled = true;
            saveSubsetWordsButton.textContent = 'æ­£åœ¨ä¿å­˜...';
            
            try {
                const parsedWordsFromInput = parseWordInput(rawWordsInput);
                const processedWordsFromInput = await processWordsForQuiz(parsedWordsFromInput);
                const existingWordsInSubset = await loadWordsFromSubset(selectedSubsetId);

                const existingWordsMap = new Map(existingWordsInSubset.map(w => [w.english.toLowerCase(), w]));
                const inputWordsMap = new Map(processedWordsFromInput.map(w => [w.english.toLowerCase(), w]));

                const batch = writeBatch(db);
                let changesMade = 0;

                for (const [key, inputWord] of inputWordsMap.entries()) {
                    if (existingWordsMap.has(key)) {
                        const existingWord = existingWordsMap.get(key);
                        if (existingWord.chinese !== inputWord.chinese) {
                            batch.update(doc(db, PUBLIC_WORDS_COLLECTION, existingWord.id), { chinese: inputWord.chinese });
                            changesMade++;
                        }
                    } else {
                        batch.set(doc(collection(db, PUBLIC_WORDS_COLLECTION)), {
                            english: inputWord.english, chinese: inputWord.chinese, subsetId: selectedSubsetId,
                            libraryId: selectedLibraryId, userId: userId
                        });
                        changesMade++;
                    }
                }

                for (const [key, existingWord] of existingWordsMap.entries()) {
                    if (!inputWordsMap.has(key)) {
                        batch.delete(doc(db, PUBLIC_WORDS_COLLECTION, existingWord.id));
                        changesMade++;
                    }
                }

                if (changesMade === 0) {
                    showMessage('æ²¡æœ‰æ–°çš„æˆ–éœ€è¦æ›´æ–°çš„å•è¯ã€‚');
                } else {
                    await batch.commit();
                    showMessage(`å•è¯å·²ä¿å­˜ï¼å…± ${changesMade} å¤„å˜æ›´ã€‚`);
                    await loadSubsetsForManageMode(selectedLibraryId);
                }
            } catch (error) {
                console.error("ä¿å­˜å•è¯å¤±è´¥:", error);
                showMessage("ä¿å­˜å•è¯å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
            } finally {
                hideLoader();
                saveSubsetWordsButton.disabled = false;
                saveSubsetWordsButton.textContent = 'ä¿å­˜å•è¯åˆ°å­é›†';
            }
        });

        const loadWordsFromSubset = async (subsetId) => {
            if (!isAuthReady || !userId || !subsetId) return [];
            try {
                const wordsRef = collection(db, PUBLIC_WORDS_COLLECTION);
                const q = query(wordsRef, where("subsetId", "==", subsetId));
                const querySnapshot = await getDocs(q);
                return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error("ä»å­é›†åŠ è½½å•è¯å¤±è´¥:", error);
                showMessage("ä»å­é›†åŠ è½½å•è¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚");
                return [];
            }
        };
        
        // --- Word Library Practice Selection Logic ---
        const buildPracticeSelectionTree = async () => {
            librarySelectionTree.innerHTML = '<p style="text-align: center; color: #777;">æ­£åœ¨åŠ è½½å•è¯åº“...</p>';
            if (!isAuthReady) return;

            try {
                const libsSnapshot = await getDocs(query(collection(db, PUBLIC_LIBRARIES_COLLECTION)));
                const allLibs = libsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                
                const subsetsSnapshot = await getDocs(query(collection(db, PUBLIC_SUBSETS_COLLECTION)));
                const allSubsets = subsetsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                
                const wordsSnapshot = await getDocs(query(collection(db, PUBLIC_WORDS_COLLECTION)));
                const allWords = wordsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));

                librarySelectionTree.innerHTML = '';
                if (allLibs.length === 0) {
                    librarySelectionTree.innerHTML = '<p style="text-align: center; color: #777;">æ²¡æœ‰å¯ç”¨çš„å•è¯åº“ã€‚</p>';
                    return;
                }

                allLibs.forEach(lib => {
                    const libNode = document.createElement('div');
                    libNode.className = 'library-node';
                    libNode.innerHTML = `<div class="library-header">${lib.name}</div>`;
                    
                    const subsetsInLib = allSubsets.filter(s => s.libraryId === lib.id);
                    if (subsetsInLib.length > 0) {
                        subsetsInLib.forEach(subset => {
                            const subsetNode = document.createElement('div');
                            subsetNode.className = 'subset-node';
                            
                            const wordsInSubset = allWords.filter(w => w.subsetId === subset.id);
                            
                            const subsetHeader = document.createElement('div');
                            subsetHeader.className = 'subset-header';
                            subsetHeader.innerHTML = `
                                <span class="subset-toggle">â–¶</span>
                                <input type="checkbox" class="subset-checkbox" data-subset-id="${subset.id}">
                                <label>${subset.name} (${wordsInSubset.length} è¯)</label>
                            `;
                            subsetNode.appendChild(subsetHeader);

                            if (wordsInSubset.length > 0) {
                                const wordsList = document.createElement('ul');
                                wordsList.className = 'words-list-container';
                                wordsList.dataset.subsetId = subset.id;
                                wordsInSubset.forEach(word => {
                                    wordsList.innerHTML += `
                                        <li class="word-item">
                                            <input type="checkbox" class="word-checkbox" data-english="${word.english}" data-chinese="${word.chinese}" data-subset-id="${subset.id}">
                                            <label>${word.english} - ${word.chinese}</label>
                                        </li>
                                    `;
                                });
                                subsetNode.appendChild(wordsList);
                            }
                            libNode.appendChild(subsetNode);
                        });
                    }
                    librarySelectionTree.appendChild(libNode);
                });

            } catch (e) {
                console.error("Error building selection tree:", e);
                librarySelectionTree.innerHTML = '<p style="text-align: center; color: #dc3545;">åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚</p>';
            }
        };

        librarySelectionTree.addEventListener('click', (e) => {
            const target = e.target;
            if (target.closest('.subset-header')) {
                const header = target.closest('.subset-header');
                const wordList = header.nextElementSibling;
                if (wordList && wordList.classList.contains('words-list-container')) {
                    header.querySelector('.subset-toggle').classList.toggle('expanded');
                    wordList.classList.toggle('show');
                }
            }
        });

        librarySelectionTree.addEventListener('change', (e) => {
            const target = e.target;
            if (target.classList.contains('subset-checkbox')) {
                const subsetId = target.dataset.subsetId;
                const isChecked = target.checked;
                const wordCheckboxes = librarySelectionTree.querySelectorAll(`.word-checkbox[data-subset-id="${subsetId}"]`);
                wordCheckboxes.forEach(cb => cb.checked = isChecked);
            }
            if (target.classList.contains('word-checkbox')) {
                const subsetId = target.dataset.subsetId;
                const allWordCheckboxes = librarySelectionTree.querySelectorAll(`.word-checkbox[data-subset-id="${subsetId}"]`);
                const checkedWordCheckboxes = librarySelectionTree.querySelectorAll(`.word-checkbox[data-subset-id="${subsetId}"]:checked`);
                const subsetCheckbox = librarySelectionTree.querySelector(`.subset-checkbox[data-subset-id="${subsetId}"]`);
                
                if (checkedWordCheckboxes.length === allWordCheckboxes.length) {
                    subsetCheckbox.checked = true;
                    subsetCheckbox.indeterminate = false;
                } else if (checkedWordCheckboxes.length > 0) {
                    subsetCheckbox.checked = false;
                    subsetCheckbox.indeterminate = true;
                } else {
                    subsetCheckbox.checked = false;
                    subsetCheckbox.indeterminate = false;
                }
            }
            
            const selectedWords = librarySelectionTree.querySelectorAll('.word-checkbox:checked');
            selectedWordCountSpan.textContent = selectedWords.length;
            confirmLibrarySelectionButton.disabled = selectedWords.length === 0;
        });

        confirmLibrarySelectionButton.addEventListener('click', () => {
            const selectedWordCheckboxes = librarySelectionTree.querySelectorAll('.word-checkbox:checked');
            words = Array.from(selectedWordCheckboxes).map(cb => ({
                english: cb.dataset.english,
                chinese: cb.dataset.chinese
            }));
            
            wordLibraryModal.style.display = 'none';
            updateSelectedLibraryDisplay();
            updateStartButtonState();
        });

        // Initial setup
        updatePracticeModeDisplay();
        updateStartButtonState();
    </script>
</body>
</html>


